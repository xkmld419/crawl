#include "Socket.h"
#include <iostream>
#include <cstring>
#include <cstdio>
using std::cout;
using std::endl;

#include "OcpMsgParser.h"



Socket *pSocket;


void receiveMsg()
{
	OcpMsgParser *pMsgParser = new OcpMsgParser("dictionary.xml");
	pMsgParser->initLocalInfo("Para@025.chinatelecom.com", "025.chinatelecom.com", "Local_IP");
	int   recv_len, msg_len, ret;
	char recvBuf[99999];
	char parserBuf[99999];
	char serviceContextId[256];
	char *data = recvBuf;    

	FILE *file = fopen("msg.data", "w");

	for(;;)
	{
		msg_len = 20;
		recv_len = 0;
		memset(recvBuf, 0, 99999);
		// 读取Dcc头部20个字节
		for( ; recv_len < msg_len  ;  )
		{
			if( (ret = pSocket->read((unsigned char *)(data+recv_len), msg_len - recv_len)) <= 0 )
			{
				cout << "receive dcc head from socket error!" << endl;
				return ;
			}
			recv_len += ret;
		}
		unsigned char buf[4];
		buf[1]=data[1];
		buf[2]=data[2];
		buf[3]=data[3];

		msg_len = buf[1]*65536+buf[2]*256+buf[3];//此为网络序转为字节序修改灵活一些
		if (msg_len >= 99999)
		{
			cout << "DCC message is too length!" << endl;
		}

		// 读取DCC消息体
		for( ; recv_len < msg_len  ;  )
		{
			if( (ret = pSocket->read((unsigned char *)(data+recv_len), msg_len - recv_len)) <= 0 )
			{
				cout << "receive dcc body from socket err!" << endl;
			}
			recv_len += ret;
		}


		fprintf(file, "%02x", data[0]);
		for (int i=1; i<msg_len; ++i)
		{
			fprintf(file, ", %02x", data[i]);
		}
		fprintf(file, "\n\n\n");
		//write (0, data, recv_len);
		// printf("%s\n", data);
		printf("\n\n\n");

		if( recv_len < msg_len - 20 )
		{
			cout << "recv length error!" << endl;
		}

		cout << "接收一条消息" << endl;
		pMsgParser->parserPack(data, 99999, parserBuf, 99999, serviceContextId);

		// printf("%s\n", parserBuf);
		// write(0, parserBuf,99999);
	

		// write (0, recvBuf, recv_len);
	}
	fclose(file);

}

void sendMsg()
{
 // /*     发送到dccTran
	char sendBuf[61441] = {
		0x01, 0x00, 0x01, 0xA0, 0x80, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0F,
	0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x01, 0x07, 0x40, 0x00, 0x00, 0x40, 0x50, 0x61, 0x72, 0x61,
	0x40, 0x30, 0x32, 0x35, 0x2E, 0x63, 0x68, 0x69, 0x6E, 0x61, 0x74, 0x65, 0x6C, 0x65, 0x63, 0x6F,
	0x6D, 0x2E, 0x63, 0x6F, 0x6D, 0x3B, 0x33, 0x34, 0x37, 0x38, 0x39, 0x33, 0x37, 0x38, 0x37, 0x36,
	0x3B, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x3B, 0x30, 0x30, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x31, 0x00, 0x00, 0x01, 0x08, 0x40, 0x00, 0x00, 0x21, 0x50, 0x61, 0x72, 0x61,
	0x40, 0x30, 0x32, 0x35, 0x2E, 0x63, 0x68, 0x69, 0x6E, 0x61, 0x74, 0x65, 0x6C, 0x65, 0x63, 0x6F,
	0x6D, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x28, 0x40, 0x00, 0x00, 0x18,
	0x63, 0x68, 0x69, 0x6E, 0x61, 0x74, 0x65, 0x6C, 0x65, 0x63, 0x6F, 0x6D, 0x2E, 0x63, 0x6F, 0x6D,
	0x00, 0x00, 0x01, 0x1B, 0x40, 0x00, 0x00, 0x18, 0x63, 0x68, 0x69, 0x6E, 0x61, 0x74, 0x65, 0x6C,
	0x65, 0x63, 0x6F, 0x6D, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x01, 0x02, 0x40, 0x00, 0x00, 0x0C,
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0xCD, 0x40, 0x00, 0x00, 0x2A, 0x43, 0x74, 0x6F, 0x43,
	0x5F, 0x4D, 0x69, 0x6E, 0x2E, 0x50, 0x61, 0x72, 0x61, 0x40, 0x30, 0x32, 0x35, 0x2E, 0x43, 0x68,
	0x69, 0x6E, 0x61, 0x54, 0x65, 0x6C, 0x65, 0x63, 0x6F, 0x6D, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xA0, 0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x9F,
	0x40, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x69, 0xC0, 0x00, 0x00, 0xA8,
	0x00, 0x01, 0x3C, 0x68, 0x00, 0x01, 0x3A, 0x10, 0xC0, 0x00, 0x00, 0x9C, 0x00, 0x01, 0x3C, 0x68,
	0x00, 0x01, 0x3A, 0x16, 0xC0, 0x00, 0x00, 0x47, 0x00, 0x01, 0x3C, 0x68, 0x30, 0x32, 0x7C, 0x32,
	0x7C, 0x38, 0x31, 0x38, 0x32, 0x33, 0x33, 0x7C, 0x38, 0x31, 0x38, 0x32, 0x33, 0x33, 0x7C, 0x55,
	0x53, 0x41, 0x7C, 0x55, 0x53, 0x41, 0x30, 0x32, 0x7C, 0x30, 0x7C, 0x30, 0x7C, 0x32, 0x30, 0x30,
	0x33, 0x30, 0x31, 0x30, 0x31, 0x7C, 0x32, 0x30, 0x33, 0x35, 0x30, 0x31, 0x30, 0x31, 0x7C, 0x32,
	0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x00, 0x00, 0x01, 0x3A, 0x16, 0xC0, 0x00, 0x00, 0x47,
	0x00, 0x01, 0x3C, 0x68, 0x30, 0x33, 0x7C, 0x32, 0x7C, 0x38, 0x31, 0x38, 0x32, 0x33, 0x33, 0x7C,
	0x38, 0x31, 0x38, 0x32, 0x33, 0x33, 0x7C, 0x55, 0x53, 0x41, 0x7C, 0x55, 0x53, 0x41, 0x30, 0x32,
	0x7C, 0x30, 0x7C, 0x30, 0x7C, 0x32, 0x30, 0x30, 0x33, 0x30, 0x31, 0x30, 0x31, 0x7C, 0x32, 0x30,
	0x33, 0x35, 0x30, 0x31, 0x30, 0x31, 0x7C, 0x32, 0x30, 0x30, 0x30, 0x30, 0x31, 0x30, 0x31, 0x00};

	char *data = sendBuf;
	unsigned char buf[4];
	buf[1]=data[1];
	buf[2]=data[2];
	buf[3]=data[3];

	int msg_len = buf[1]*65536+buf[2]*256+buf[3];//此为网络序转为字节序修改灵活一些
 // */

/*    发送到前台模拟客户端
	char sendBuf[61441] = {
		0x01, 0x00, 0x01, 0x14, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 
		0x00, 0x04, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x14, 
		0x00, 0x00, 0x01, 0x07, 0x40, 0x00, 0x00, 0x40, 0x50, 0x61, 
		0x72, 0x61, 0x40, 0x30, 0x32, 0x35, 0x2e, 0x63, 0x68, 0x69, 
		0x6e, 0x61, 0x74, 0x65, 0x6c, 0x65, 0x63, 0x6f, 0x6d, 0x2e, 
		0x63, 0x6f, 0x6d, 0x3b, 0x33, 0x34, 0x37, 0x38, 0x39, 0x33, 
		0x37, 0x38, 0x37, 0x36, 0x3b, 0x39, 0x39, 0x39, 0x39, 0x39, 
		0x39, 0x39, 0x39, 0x39, 0x39, 0x3b, 0x30, 0x30, 0x30, 0x30, 
		0x30, 0x30, 0x30, 0x31, 0x00, 0x00, 0x01, 0x0c, 0x40, 0x00, 
		0x00, 0x0c, 0x00, 0x00, 0x07, 0xd1, 0x00, 0x00, 0x01, 0x08, 
		0x40, 0x00, 0x00, 0x21, 0x50, 0x61, 0x72, 0x61, 0x40, 0x30, 
		0x32, 0x35, 0x2e, 0x63, 0x68, 0x69, 0x6e, 0x61, 0x74, 0x65, 
		0x6c, 0x65, 0x63, 0x6f, 0x6d, 0x2e, 0x63, 0x6f, 0x6d, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x01, 0x28, 0x40, 0x00, 0x00, 0x1c, 
		0x30, 0x32, 0x35, 0x2e, 0x63, 0x68, 0x69, 0x6e, 0x61, 0x74, 
		0x65, 0x6c, 0x65, 0x63, 0x6f, 0x6d, 0x2e, 0x63, 0x6f, 0x6d, 
		0x00, 0x00, 0x01, 0x02, 0x40, 0x00, 0x00, 0x0c, 0x00, 0x00, 
		0x00, 0x04, 0x00, 0x00, 0x01, 0xa0, 0x40, 0x00, 0x00, 0x0c, 
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x9f, 0x40, 0x00, 
		0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x69, 
		0xc0, 0x00, 0x00, 0x28, 0x00, 0x00, 0x28, 0xaf, 0x00, 0x00, 
		0x50, 0x97, 0xc0, 0x00, 0x00, 0x10, 0x00, 0x01, 0x3c, 0x68, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x17, 0xc0, 0x00, 
		0x00, 0x0c, 0x00, 0x01, 0x3c, 0x68, 0x00, 0x00, 0x03, 0x69, 
		0xc0, 0x00, 0x00, 0x28, 0x00, 0x00, 0x28, 0xaf, 0x00, 0x00, 
		0x50, 0x97, 0xc0, 0x00, 0x00, 0x10, 0x00, 0x01, 0x3c, 0x68, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3a, 0x17, 0xc0, 0x00, 
		0x00, 0x0c, 0x00, 0x01, 0x3c, 0x68 };
	char *data = sendBuf;
	int msg_len = strlen(data);
*/

	int num = 0;
	int iRet = 0;

	/* // */	for (;;)         // 发送到前台模拟客户端时取消掉注释
	// for (int i=0; i<2; ++i)
	{
		num = 0;
		iRet = 0;

		for ( ; num < msg_len ; )
		{
			iRet = pSocket->write ( (unsigned char *)(data + num), msg_len - num );

			if( iRet < 0 )
			{
				cout << "socket send active CCR err!" << endl;
			}
			num += iRet;
		}
		cout << "发送一条消息" << endl;
		sleep(30);
	}

}

int main()
{
	pSocket = new Socket;

	int ret = pSocket->listen(3325);
	if (ret < 0)
	{
		cout << "socket listen error!" << endl;
		return -1;
	}

	switch(fork())
	{
	case -1:
		cout << "fork erro!" << endl;
		break;
	case 0:
		receiveMsg();
		break;
	default:
		sendMsg();
		break;
	}

	return 0;
}

