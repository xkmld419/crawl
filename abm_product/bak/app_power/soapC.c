/* soapC.c
   Generated by gSOAP 2.7.15 from WebService.h
   Copyright(C) 2000-2009, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.15 2010-11-09 08:06:56 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header));
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns1__VpdnOnlineIPResponse:
		return soap_in_ns1__VpdnOnlineIPResponse(soap, NULL, NULL, "ns1:VpdnOnlineIPResponse");
	case SOAP_TYPE_ns1__VpdnOnlineIPRequest:
		return soap_in_ns1__VpdnOnlineIPRequest(soap, NULL, NULL, "ns1:VpdnOnlineIPRequest");
	case SOAP_TYPE_ns1__VpdnIPResponse:
		return soap_in_ns1__VpdnIPResponse(soap, NULL, NULL, "ns1:VpdnIPResponse");
	case SOAP_TYPE_ns1__VpdnIPRequest:
		return soap_in_ns1__VpdnIPRequest(soap, NULL, NULL, "ns1:VpdnIPRequest");
	case SOAP_TYPE_PointerTo_ns2__callResponse:
		return soap_in_PointerTo_ns2__callResponse(soap, NULL, NULL, "ns2:callResponse");
	case SOAP_TYPE_PointerTo_ns2__call:
		return soap_in_PointerTo_ns2__call(soap, NULL, NULL, "ns2:call");
	case SOAP_TYPE_PointerTo_ns2__executeXMLResponse:
		return soap_in_PointerTo_ns2__executeXMLResponse(soap, NULL, NULL, "ns2:executeXMLResponse");
	case SOAP_TYPE_PointerTo_ns2__executeXML:
		return soap_in_PointerTo_ns2__executeXML(soap, NULL, NULL, "ns2:executeXML");
	case SOAP_TYPE_PointerTo_ns2__executeQueryOraResponse:
		return soap_in_PointerTo_ns2__executeQueryOraResponse(soap, NULL, NULL, "ns2:executeQueryOraResponse");
	case SOAP_TYPE_PointerTo_ns2__executeQueryOra:
		return soap_in_PointerTo_ns2__executeQueryOra(soap, NULL, NULL, "ns2:executeQueryOra");
	case SOAP_TYPE_PointerTo_ns2__executeProcedureResponse:
		return soap_in_PointerTo_ns2__executeProcedureResponse(soap, NULL, NULL, "ns2:executeProcedureResponse");
	case SOAP_TYPE_PointerTo_ns2__executeProcedure:
		return soap_in_PointerTo_ns2__executeProcedure(soap, NULL, NULL, "ns2:executeProcedure");
	case SOAP_TYPE_PointerTo_ns2__executeQueryExResponse:
		return soap_in_PointerTo_ns2__executeQueryExResponse(soap, NULL, NULL, "ns2:executeQueryExResponse");
	case SOAP_TYPE_PointerTo_ns2__executeQueryEx:
		return soap_in_PointerTo_ns2__executeQueryEx(soap, NULL, NULL, "ns2:executeQueryEx");
	case SOAP_TYPE_PointerTo_ns2__executeQueryResponse:
		return soap_in_PointerTo_ns2__executeQueryResponse(soap, NULL, NULL, "ns2:executeQueryResponse");
	case SOAP_TYPE_PointerTo_ns2__executeQuery:
		return soap_in_PointerTo_ns2__executeQuery(soap, NULL, NULL, "ns2:executeQuery");
	case SOAP_TYPE_PointerTo_ns2__executeProcedureExResponse:
		return soap_in_PointerTo_ns2__executeProcedureExResponse(soap, NULL, NULL, "ns2:executeProcedureExResponse");
	case SOAP_TYPE_PointerTo_ns2__executeProcedureEx:
		return soap_in_PointerTo_ns2__executeProcedureEx(soap, NULL, NULL, "ns2:executeProcedureEx");
	case SOAP_TYPE_PointerTo_ns2__executeSqlExResponse:
		return soap_in_PointerTo_ns2__executeSqlExResponse(soap, NULL, NULL, "ns2:executeSqlExResponse");
	case SOAP_TYPE_PointerTo_ns2__executeSqlEx:
		return soap_in_PointerTo_ns2__executeSqlEx(soap, NULL, NULL, "ns2:executeSqlEx");
	case SOAP_TYPE_PointerTo_ns2__executeUpdateResponse:
		return soap_in_PointerTo_ns2__executeUpdateResponse(soap, NULL, NULL, "ns2:executeUpdateResponse");
	case SOAP_TYPE_PointerTo_ns2__executeUpdate:
		return soap_in_PointerTo_ns2__executeUpdate(soap, NULL, NULL, "ns2:executeUpdate");
	case SOAP_TYPE_PointerTo_ns2__executeSqlResponse:
		return soap_in_PointerTo_ns2__executeSqlResponse(soap, NULL, NULL, "ns2:executeSqlResponse");
	case SOAP_TYPE_PointerTo_ns2__executeSql:
		return soap_in_PointerTo_ns2__executeSql(soap, NULL, NULL, "ns2:executeSql");
	case SOAP_TYPE_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse:
		return soap_in_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse(soap, NULL, NULL, "ns1:GetVpdnOnlineIPByImsiResponse");
	case SOAP_TYPE_PointerTo_ns1__GetVpdnOnlineIPByImsi:
		return soap_in_PointerTo_ns1__GetVpdnOnlineIPByImsi(soap, NULL, NULL, "ns1:GetVpdnOnlineIPByImsi");
	case SOAP_TYPE_PointerTo_ns1__GetVpdnIPByImsiResponse:
		return soap_in_PointerTo_ns1__GetVpdnIPByImsiResponse(soap, NULL, NULL, "ns1:GetVpdnIPByImsiResponse");
	case SOAP_TYPE_PointerTo_ns1__GetVpdnIPByImsi:
		return soap_in_PointerTo_ns1__GetVpdnIPByImsi(soap, NULL, NULL, "ns1:GetVpdnIPByImsi");
	case SOAP_TYPE_PointerTons1__VpdnOnlineIPResponse:
		return soap_in_PointerTons1__VpdnOnlineIPResponse(soap, NULL, NULL, "ns1:VpdnOnlineIPResponse");
	case SOAP_TYPE_PointerTons1__VpdnOnlineIPRequest:
		return soap_in_PointerTons1__VpdnOnlineIPRequest(soap, NULL, NULL, "ns1:VpdnOnlineIPRequest");
	case SOAP_TYPE_PointerTons1__VpdnIPResponse:
		return soap_in_PointerTons1__VpdnIPResponse(soap, NULL, NULL, "ns1:VpdnIPResponse");
	case SOAP_TYPE_PointerTons1__VpdnIPRequest:
		return soap_in_PointerTons1__VpdnIPRequest(soap, NULL, NULL, "ns1:VpdnIPRequest");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VpdnOnlineIPResponse"))
		{	*type = SOAP_TYPE_ns1__VpdnOnlineIPResponse;
			return soap_in_ns1__VpdnOnlineIPResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VpdnOnlineIPRequest"))
		{	*type = SOAP_TYPE_ns1__VpdnOnlineIPRequest;
			return soap_in_ns1__VpdnOnlineIPRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VpdnIPResponse"))
		{	*type = SOAP_TYPE_ns1__VpdnIPResponse;
			return soap_in_ns1__VpdnIPResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:VpdnIPRequest"))
		{	*type = SOAP_TYPE_ns1__VpdnIPRequest;
			return soap_in_ns1__VpdnIPRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:callResponse"))
		{	*type = SOAP_TYPE__ns2__callResponse;
			return soap_in__ns2__callResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:call"))
		{	*type = SOAP_TYPE__ns2__call;
			return soap_in__ns2__call(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeXMLResponse"))
		{	*type = SOAP_TYPE__ns2__executeXMLResponse;
			return soap_in__ns2__executeXMLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeXML"))
		{	*type = SOAP_TYPE__ns2__executeXML;
			return soap_in__ns2__executeXML(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeQueryOraResponse"))
		{	*type = SOAP_TYPE__ns2__executeQueryOraResponse;
			return soap_in__ns2__executeQueryOraResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeQueryOra"))
		{	*type = SOAP_TYPE__ns2__executeQueryOra;
			return soap_in__ns2__executeQueryOra(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeProcedureResponse"))
		{	*type = SOAP_TYPE__ns2__executeProcedureResponse;
			return soap_in__ns2__executeProcedureResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeProcedure"))
		{	*type = SOAP_TYPE__ns2__executeProcedure;
			return soap_in__ns2__executeProcedure(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeQueryExResponse"))
		{	*type = SOAP_TYPE__ns2__executeQueryExResponse;
			return soap_in__ns2__executeQueryExResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeQueryEx"))
		{	*type = SOAP_TYPE__ns2__executeQueryEx;
			return soap_in__ns2__executeQueryEx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeQueryResponse"))
		{	*type = SOAP_TYPE__ns2__executeQueryResponse;
			return soap_in__ns2__executeQueryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeQuery"))
		{	*type = SOAP_TYPE__ns2__executeQuery;
			return soap_in__ns2__executeQuery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeProcedureExResponse"))
		{	*type = SOAP_TYPE__ns2__executeProcedureExResponse;
			return soap_in__ns2__executeProcedureExResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeProcedureEx"))
		{	*type = SOAP_TYPE__ns2__executeProcedureEx;
			return soap_in__ns2__executeProcedureEx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeSqlExResponse"))
		{	*type = SOAP_TYPE__ns2__executeSqlExResponse;
			return soap_in__ns2__executeSqlExResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeSqlEx"))
		{	*type = SOAP_TYPE__ns2__executeSqlEx;
			return soap_in__ns2__executeSqlEx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeUpdateResponse"))
		{	*type = SOAP_TYPE__ns2__executeUpdateResponse;
			return soap_in__ns2__executeUpdateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeUpdate"))
		{	*type = SOAP_TYPE__ns2__executeUpdate;
			return soap_in__ns2__executeUpdate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeSqlResponse"))
		{	*type = SOAP_TYPE__ns2__executeSqlResponse;
			return soap_in__ns2__executeSqlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:executeSql"))
		{	*type = SOAP_TYPE__ns2__executeSql;
			return soap_in__ns2__executeSql(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVpdnOnlineIPByImsiResponse"))
		{	*type = SOAP_TYPE__ns1__GetVpdnOnlineIPByImsiResponse;
			return soap_in__ns1__GetVpdnOnlineIPByImsiResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVpdnOnlineIPByImsi"))
		{	*type = SOAP_TYPE__ns1__GetVpdnOnlineIPByImsi;
			return soap_in__ns1__GetVpdnOnlineIPByImsi(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVpdnIPByImsiResponse"))
		{	*type = SOAP_TYPE__ns1__GetVpdnIPByImsiResponse;
			return soap_in__ns1__GetVpdnIPByImsiResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVpdnIPByImsi"))
		{	*type = SOAP_TYPE__ns1__GetVpdnIPByImsi;
			return soap_in__ns1__GetVpdnIPByImsi(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__ns2__callResponse:
		return soap_out__ns2__callResponse(soap, "ns2:callResponse", id, (const struct _ns2__callResponse *)ptr, NULL);
	case SOAP_TYPE__ns2__call:
		return soap_out__ns2__call(soap, "ns2:call", id, (const struct _ns2__call *)ptr, NULL);
	case SOAP_TYPE__ns2__executeXMLResponse:
		return soap_out__ns2__executeXMLResponse(soap, "ns2:executeXMLResponse", id, (const struct _ns2__executeXMLResponse *)ptr, NULL);
	case SOAP_TYPE__ns2__executeXML:
		return soap_out__ns2__executeXML(soap, "ns2:executeXML", id, (const struct _ns2__executeXML *)ptr, NULL);
	case SOAP_TYPE__ns2__executeQueryOraResponse:
		return soap_out__ns2__executeQueryOraResponse(soap, "ns2:executeQueryOraResponse", id, (const struct _ns2__executeQueryOraResponse *)ptr, NULL);
	case SOAP_TYPE__ns2__executeQueryOra:
		return soap_out__ns2__executeQueryOra(soap, "ns2:executeQueryOra", id, (const struct _ns2__executeQueryOra *)ptr, NULL);
	case SOAP_TYPE__ns2__executeProcedureResponse:
		return soap_out__ns2__executeProcedureResponse(soap, "ns2:executeProcedureResponse", id, (const struct _ns2__executeProcedureResponse *)ptr, NULL);
	case SOAP_TYPE__ns2__executeProcedure:
		return soap_out__ns2__executeProcedure(soap, "ns2:executeProcedure", id, (const struct _ns2__executeProcedure *)ptr, NULL);
	case SOAP_TYPE__ns2__executeQueryExResponse:
		return soap_out__ns2__executeQueryExResponse(soap, "ns2:executeQueryExResponse", id, (const struct _ns2__executeQueryExResponse *)ptr, NULL);
	case SOAP_TYPE__ns2__executeQueryEx:
		return soap_out__ns2__executeQueryEx(soap, "ns2:executeQueryEx", id, (const struct _ns2__executeQueryEx *)ptr, NULL);
	case SOAP_TYPE__ns2__executeQueryResponse:
		return soap_out__ns2__executeQueryResponse(soap, "ns2:executeQueryResponse", id, (const struct _ns2__executeQueryResponse *)ptr, NULL);
	case SOAP_TYPE__ns2__executeQuery:
		return soap_out__ns2__executeQuery(soap, "ns2:executeQuery", id, (const struct _ns2__executeQuery *)ptr, NULL);
	case SOAP_TYPE__ns2__executeProcedureExResponse:
		return soap_out__ns2__executeProcedureExResponse(soap, "ns2:executeProcedureExResponse", id, (const struct _ns2__executeProcedureExResponse *)ptr, NULL);
	case SOAP_TYPE__ns2__executeProcedureEx:
		return soap_out__ns2__executeProcedureEx(soap, "ns2:executeProcedureEx", id, (const struct _ns2__executeProcedureEx *)ptr, NULL);
	case SOAP_TYPE__ns2__executeSqlExResponse:
		return soap_out__ns2__executeSqlExResponse(soap, "ns2:executeSqlExResponse", id, (const struct _ns2__executeSqlExResponse *)ptr, NULL);
	case SOAP_TYPE__ns2__executeSqlEx:
		return soap_out__ns2__executeSqlEx(soap, "ns2:executeSqlEx", id, (const struct _ns2__executeSqlEx *)ptr, NULL);
	case SOAP_TYPE__ns2__executeUpdateResponse:
		return soap_out__ns2__executeUpdateResponse(soap, "ns2:executeUpdateResponse", id, (const struct _ns2__executeUpdateResponse *)ptr, NULL);
	case SOAP_TYPE__ns2__executeUpdate:
		return soap_out__ns2__executeUpdate(soap, "ns2:executeUpdate", id, (const struct _ns2__executeUpdate *)ptr, NULL);
	case SOAP_TYPE__ns2__executeSqlResponse:
		return soap_out__ns2__executeSqlResponse(soap, "ns2:executeSqlResponse", id, (const struct _ns2__executeSqlResponse *)ptr, NULL);
	case SOAP_TYPE__ns2__executeSql:
		return soap_out__ns2__executeSql(soap, "ns2:executeSql", id, (const struct _ns2__executeSql *)ptr, NULL);
	case SOAP_TYPE__ns1__GetVpdnOnlineIPByImsiResponse:
		return soap_out__ns1__GetVpdnOnlineIPByImsiResponse(soap, "ns1:GetVpdnOnlineIPByImsiResponse", id, (const struct _ns1__GetVpdnOnlineIPByImsiResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetVpdnOnlineIPByImsi:
		return soap_out__ns1__GetVpdnOnlineIPByImsi(soap, "ns1:GetVpdnOnlineIPByImsi", id, (const struct _ns1__GetVpdnOnlineIPByImsi *)ptr, NULL);
	case SOAP_TYPE__ns1__GetVpdnIPByImsiResponse:
		return soap_out__ns1__GetVpdnIPByImsiResponse(soap, "ns1:GetVpdnIPByImsiResponse", id, (const struct _ns1__GetVpdnIPByImsiResponse *)ptr, NULL);
	case SOAP_TYPE__ns1__GetVpdnIPByImsi:
		return soap_out__ns1__GetVpdnIPByImsi(soap, "ns1:GetVpdnIPByImsi", id, (const struct _ns1__GetVpdnIPByImsi *)ptr, NULL);
	case SOAP_TYPE_ns1__VpdnOnlineIPResponse:
		return soap_out_ns1__VpdnOnlineIPResponse(soap, tag, id, (const struct ns1__VpdnOnlineIPResponse *)ptr, "ns1:VpdnOnlineIPResponse");
	case SOAP_TYPE_ns1__VpdnOnlineIPRequest:
		return soap_out_ns1__VpdnOnlineIPRequest(soap, tag, id, (const struct ns1__VpdnOnlineIPRequest *)ptr, "ns1:VpdnOnlineIPRequest");
	case SOAP_TYPE_ns1__VpdnIPResponse:
		return soap_out_ns1__VpdnIPResponse(soap, tag, id, (const struct ns1__VpdnIPResponse *)ptr, "ns1:VpdnIPResponse");
	case SOAP_TYPE_ns1__VpdnIPRequest:
		return soap_out_ns1__VpdnIPRequest(soap, tag, id, (const struct ns1__VpdnIPRequest *)ptr, "ns1:VpdnIPRequest");
	case SOAP_TYPE_PointerTo_ns2__callResponse:
		return soap_out_PointerTo_ns2__callResponse(soap, tag, id, (struct _ns2__callResponse *const*)ptr, "ns2:callResponse");
	case SOAP_TYPE_PointerTo_ns2__call:
		return soap_out_PointerTo_ns2__call(soap, tag, id, (struct _ns2__call *const*)ptr, "ns2:call");
	case SOAP_TYPE_PointerTo_ns2__executeXMLResponse:
		return soap_out_PointerTo_ns2__executeXMLResponse(soap, tag, id, (struct _ns2__executeXMLResponse *const*)ptr, "ns2:executeXMLResponse");
	case SOAP_TYPE_PointerTo_ns2__executeXML:
		return soap_out_PointerTo_ns2__executeXML(soap, tag, id, (struct _ns2__executeXML *const*)ptr, "ns2:executeXML");
	case SOAP_TYPE_PointerTo_ns2__executeQueryOraResponse:
		return soap_out_PointerTo_ns2__executeQueryOraResponse(soap, tag, id, (struct _ns2__executeQueryOraResponse *const*)ptr, "ns2:executeQueryOraResponse");
	case SOAP_TYPE_PointerTo_ns2__executeQueryOra:
		return soap_out_PointerTo_ns2__executeQueryOra(soap, tag, id, (struct _ns2__executeQueryOra *const*)ptr, "ns2:executeQueryOra");
	case SOAP_TYPE_PointerTo_ns2__executeProcedureResponse:
		return soap_out_PointerTo_ns2__executeProcedureResponse(soap, tag, id, (struct _ns2__executeProcedureResponse *const*)ptr, "ns2:executeProcedureResponse");
	case SOAP_TYPE_PointerTo_ns2__executeProcedure:
		return soap_out_PointerTo_ns2__executeProcedure(soap, tag, id, (struct _ns2__executeProcedure *const*)ptr, "ns2:executeProcedure");
	case SOAP_TYPE_PointerTo_ns2__executeQueryExResponse:
		return soap_out_PointerTo_ns2__executeQueryExResponse(soap, tag, id, (struct _ns2__executeQueryExResponse *const*)ptr, "ns2:executeQueryExResponse");
	case SOAP_TYPE_PointerTo_ns2__executeQueryEx:
		return soap_out_PointerTo_ns2__executeQueryEx(soap, tag, id, (struct _ns2__executeQueryEx *const*)ptr, "ns2:executeQueryEx");
	case SOAP_TYPE_PointerTo_ns2__executeQueryResponse:
		return soap_out_PointerTo_ns2__executeQueryResponse(soap, tag, id, (struct _ns2__executeQueryResponse *const*)ptr, "ns2:executeQueryResponse");
	case SOAP_TYPE_PointerTo_ns2__executeQuery:
		return soap_out_PointerTo_ns2__executeQuery(soap, tag, id, (struct _ns2__executeQuery *const*)ptr, "ns2:executeQuery");
	case SOAP_TYPE_PointerTo_ns2__executeProcedureExResponse:
		return soap_out_PointerTo_ns2__executeProcedureExResponse(soap, tag, id, (struct _ns2__executeProcedureExResponse *const*)ptr, "ns2:executeProcedureExResponse");
	case SOAP_TYPE_PointerTo_ns2__executeProcedureEx:
		return soap_out_PointerTo_ns2__executeProcedureEx(soap, tag, id, (struct _ns2__executeProcedureEx *const*)ptr, "ns2:executeProcedureEx");
	case SOAP_TYPE_PointerTo_ns2__executeSqlExResponse:
		return soap_out_PointerTo_ns2__executeSqlExResponse(soap, tag, id, (struct _ns2__executeSqlExResponse *const*)ptr, "ns2:executeSqlExResponse");
	case SOAP_TYPE_PointerTo_ns2__executeSqlEx:
		return soap_out_PointerTo_ns2__executeSqlEx(soap, tag, id, (struct _ns2__executeSqlEx *const*)ptr, "ns2:executeSqlEx");
	case SOAP_TYPE_PointerTo_ns2__executeUpdateResponse:
		return soap_out_PointerTo_ns2__executeUpdateResponse(soap, tag, id, (struct _ns2__executeUpdateResponse *const*)ptr, "ns2:executeUpdateResponse");
	case SOAP_TYPE_PointerTo_ns2__executeUpdate:
		return soap_out_PointerTo_ns2__executeUpdate(soap, tag, id, (struct _ns2__executeUpdate *const*)ptr, "ns2:executeUpdate");
	case SOAP_TYPE_PointerTo_ns2__executeSqlResponse:
		return soap_out_PointerTo_ns2__executeSqlResponse(soap, tag, id, (struct _ns2__executeSqlResponse *const*)ptr, "ns2:executeSqlResponse");
	case SOAP_TYPE_PointerTo_ns2__executeSql:
		return soap_out_PointerTo_ns2__executeSql(soap, tag, id, (struct _ns2__executeSql *const*)ptr, "ns2:executeSql");
	case SOAP_TYPE_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse:
		return soap_out_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse(soap, tag, id, (struct _ns1__GetVpdnOnlineIPByImsiResponse *const*)ptr, "ns1:GetVpdnOnlineIPByImsiResponse");
	case SOAP_TYPE_PointerTo_ns1__GetVpdnOnlineIPByImsi:
		return soap_out_PointerTo_ns1__GetVpdnOnlineIPByImsi(soap, tag, id, (struct _ns1__GetVpdnOnlineIPByImsi *const*)ptr, "ns1:GetVpdnOnlineIPByImsi");
	case SOAP_TYPE_PointerTo_ns1__GetVpdnIPByImsiResponse:
		return soap_out_PointerTo_ns1__GetVpdnIPByImsiResponse(soap, tag, id, (struct _ns1__GetVpdnIPByImsiResponse *const*)ptr, "ns1:GetVpdnIPByImsiResponse");
	case SOAP_TYPE_PointerTo_ns1__GetVpdnIPByImsi:
		return soap_out_PointerTo_ns1__GetVpdnIPByImsi(soap, tag, id, (struct _ns1__GetVpdnIPByImsi *const*)ptr, "ns1:GetVpdnIPByImsi");
	case SOAP_TYPE_PointerTons1__VpdnOnlineIPResponse:
		return soap_out_PointerTons1__VpdnOnlineIPResponse(soap, tag, id, (struct ns1__VpdnOnlineIPResponse *const*)ptr, "ns1:VpdnOnlineIPResponse");
	case SOAP_TYPE_PointerTons1__VpdnOnlineIPRequest:
		return soap_out_PointerTons1__VpdnOnlineIPRequest(soap, tag, id, (struct ns1__VpdnOnlineIPRequest *const*)ptr, "ns1:VpdnOnlineIPRequest");
	case SOAP_TYPE_PointerTons1__VpdnIPResponse:
		return soap_out_PointerTons1__VpdnIPResponse(soap, tag, id, (struct ns1__VpdnIPResponse *const*)ptr, "ns1:VpdnIPResponse");
	case SOAP_TYPE_PointerTons1__VpdnIPRequest:
		return soap_out_PointerTons1__VpdnIPRequest(soap, tag, id, (struct ns1__VpdnIPRequest *const*)ptr, "ns1:VpdnIPRequest");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___ns2__call:
		soap_serialize___ns2__call(soap, (const struct __ns2__call *)ptr);
		break;
	case SOAP_TYPE___ns2__executeXML:
		soap_serialize___ns2__executeXML(soap, (const struct __ns2__executeXML *)ptr);
		break;
	case SOAP_TYPE___ns2__executeQueryOra:
		soap_serialize___ns2__executeQueryOra(soap, (const struct __ns2__executeQueryOra *)ptr);
		break;
	case SOAP_TYPE___ns2__executeProcedure:
		soap_serialize___ns2__executeProcedure(soap, (const struct __ns2__executeProcedure *)ptr);
		break;
	case SOAP_TYPE___ns2__executeQueryEx:
		soap_serialize___ns2__executeQueryEx(soap, (const struct __ns2__executeQueryEx *)ptr);
		break;
	case SOAP_TYPE___ns2__executeQuery:
		soap_serialize___ns2__executeQuery(soap, (const struct __ns2__executeQuery *)ptr);
		break;
	case SOAP_TYPE___ns2__executeProcedureEx:
		soap_serialize___ns2__executeProcedureEx(soap, (const struct __ns2__executeProcedureEx *)ptr);
		break;
	case SOAP_TYPE___ns2__executeSqlEx:
		soap_serialize___ns2__executeSqlEx(soap, (const struct __ns2__executeSqlEx *)ptr);
		break;
	case SOAP_TYPE___ns2__executeUpdate:
		soap_serialize___ns2__executeUpdate(soap, (const struct __ns2__executeUpdate *)ptr);
		break;
	case SOAP_TYPE___ns2__executeSql:
		soap_serialize___ns2__executeSql(soap, (const struct __ns2__executeSql *)ptr);
		break;
	case SOAP_TYPE___ns1__GetVpdnOnlineIPByImsi:
		soap_serialize___ns1__GetVpdnOnlineIPByImsi(soap, (const struct __ns1__GetVpdnOnlineIPByImsi *)ptr);
		break;
	case SOAP_TYPE___ns1__GetVpdnIPByImsi:
		soap_serialize___ns1__GetVpdnIPByImsi(soap, (const struct __ns1__GetVpdnIPByImsi *)ptr);
		break;
	case SOAP_TYPE__ns2__callResponse:
		soap_serialize__ns2__callResponse(soap, (const struct _ns2__callResponse *)ptr);
		break;
	case SOAP_TYPE__ns2__call:
		soap_serialize__ns2__call(soap, (const struct _ns2__call *)ptr);
		break;
	case SOAP_TYPE__ns2__executeXMLResponse:
		soap_serialize__ns2__executeXMLResponse(soap, (const struct _ns2__executeXMLResponse *)ptr);
		break;
	case SOAP_TYPE__ns2__executeXML:
		soap_serialize__ns2__executeXML(soap, (const struct _ns2__executeXML *)ptr);
		break;
	case SOAP_TYPE__ns2__executeQueryOraResponse:
		soap_serialize__ns2__executeQueryOraResponse(soap, (const struct _ns2__executeQueryOraResponse *)ptr);
		break;
	case SOAP_TYPE__ns2__executeQueryOra:
		soap_serialize__ns2__executeQueryOra(soap, (const struct _ns2__executeQueryOra *)ptr);
		break;
	case SOAP_TYPE__ns2__executeProcedureResponse:
		soap_serialize__ns2__executeProcedureResponse(soap, (const struct _ns2__executeProcedureResponse *)ptr);
		break;
	case SOAP_TYPE__ns2__executeProcedure:
		soap_serialize__ns2__executeProcedure(soap, (const struct _ns2__executeProcedure *)ptr);
		break;
	case SOAP_TYPE__ns2__executeQueryExResponse:
		soap_serialize__ns2__executeQueryExResponse(soap, (const struct _ns2__executeQueryExResponse *)ptr);
		break;
	case SOAP_TYPE__ns2__executeQueryEx:
		soap_serialize__ns2__executeQueryEx(soap, (const struct _ns2__executeQueryEx *)ptr);
		break;
	case SOAP_TYPE__ns2__executeQueryResponse:
		soap_serialize__ns2__executeQueryResponse(soap, (const struct _ns2__executeQueryResponse *)ptr);
		break;
	case SOAP_TYPE__ns2__executeQuery:
		soap_serialize__ns2__executeQuery(soap, (const struct _ns2__executeQuery *)ptr);
		break;
	case SOAP_TYPE__ns2__executeProcedureExResponse:
		soap_serialize__ns2__executeProcedureExResponse(soap, (const struct _ns2__executeProcedureExResponse *)ptr);
		break;
	case SOAP_TYPE__ns2__executeProcedureEx:
		soap_serialize__ns2__executeProcedureEx(soap, (const struct _ns2__executeProcedureEx *)ptr);
		break;
	case SOAP_TYPE__ns2__executeSqlExResponse:
		soap_serialize__ns2__executeSqlExResponse(soap, (const struct _ns2__executeSqlExResponse *)ptr);
		break;
	case SOAP_TYPE__ns2__executeSqlEx:
		soap_serialize__ns2__executeSqlEx(soap, (const struct _ns2__executeSqlEx *)ptr);
		break;
	case SOAP_TYPE__ns2__executeUpdateResponse:
		soap_serialize__ns2__executeUpdateResponse(soap, (const struct _ns2__executeUpdateResponse *)ptr);
		break;
	case SOAP_TYPE__ns2__executeUpdate:
		soap_serialize__ns2__executeUpdate(soap, (const struct _ns2__executeUpdate *)ptr);
		break;
	case SOAP_TYPE__ns2__executeSqlResponse:
		soap_serialize__ns2__executeSqlResponse(soap, (const struct _ns2__executeSqlResponse *)ptr);
		break;
	case SOAP_TYPE__ns2__executeSql:
		soap_serialize__ns2__executeSql(soap, (const struct _ns2__executeSql *)ptr);
		break;
	case SOAP_TYPE__ns1__GetVpdnOnlineIPByImsiResponse:
		soap_serialize__ns1__GetVpdnOnlineIPByImsiResponse(soap, (const struct _ns1__GetVpdnOnlineIPByImsiResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetVpdnOnlineIPByImsi:
		soap_serialize__ns1__GetVpdnOnlineIPByImsi(soap, (const struct _ns1__GetVpdnOnlineIPByImsi *)ptr);
		break;
	case SOAP_TYPE__ns1__GetVpdnIPByImsiResponse:
		soap_serialize__ns1__GetVpdnIPByImsiResponse(soap, (const struct _ns1__GetVpdnIPByImsiResponse *)ptr);
		break;
	case SOAP_TYPE__ns1__GetVpdnIPByImsi:
		soap_serialize__ns1__GetVpdnIPByImsi(soap, (const struct _ns1__GetVpdnIPByImsi *)ptr);
		break;
	case SOAP_TYPE_ns1__VpdnOnlineIPResponse:
		soap_serialize_ns1__VpdnOnlineIPResponse(soap, (const struct ns1__VpdnOnlineIPResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__VpdnOnlineIPRequest:
		soap_serialize_ns1__VpdnOnlineIPRequest(soap, (const struct ns1__VpdnOnlineIPRequest *)ptr);
		break;
	case SOAP_TYPE_ns1__VpdnIPResponse:
		soap_serialize_ns1__VpdnIPResponse(soap, (const struct ns1__VpdnIPResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__VpdnIPRequest:
		soap_serialize_ns1__VpdnIPRequest(soap, (const struct ns1__VpdnIPRequest *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__callResponse:
		soap_serialize_PointerTo_ns2__callResponse(soap, (struct _ns2__callResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__call:
		soap_serialize_PointerTo_ns2__call(soap, (struct _ns2__call *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeXMLResponse:
		soap_serialize_PointerTo_ns2__executeXMLResponse(soap, (struct _ns2__executeXMLResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeXML:
		soap_serialize_PointerTo_ns2__executeXML(soap, (struct _ns2__executeXML *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeQueryOraResponse:
		soap_serialize_PointerTo_ns2__executeQueryOraResponse(soap, (struct _ns2__executeQueryOraResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeQueryOra:
		soap_serialize_PointerTo_ns2__executeQueryOra(soap, (struct _ns2__executeQueryOra *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeProcedureResponse:
		soap_serialize_PointerTo_ns2__executeProcedureResponse(soap, (struct _ns2__executeProcedureResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeProcedure:
		soap_serialize_PointerTo_ns2__executeProcedure(soap, (struct _ns2__executeProcedure *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeQueryExResponse:
		soap_serialize_PointerTo_ns2__executeQueryExResponse(soap, (struct _ns2__executeQueryExResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeQueryEx:
		soap_serialize_PointerTo_ns2__executeQueryEx(soap, (struct _ns2__executeQueryEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeQueryResponse:
		soap_serialize_PointerTo_ns2__executeQueryResponse(soap, (struct _ns2__executeQueryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeQuery:
		soap_serialize_PointerTo_ns2__executeQuery(soap, (struct _ns2__executeQuery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeProcedureExResponse:
		soap_serialize_PointerTo_ns2__executeProcedureExResponse(soap, (struct _ns2__executeProcedureExResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeProcedureEx:
		soap_serialize_PointerTo_ns2__executeProcedureEx(soap, (struct _ns2__executeProcedureEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeSqlExResponse:
		soap_serialize_PointerTo_ns2__executeSqlExResponse(soap, (struct _ns2__executeSqlExResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeSqlEx:
		soap_serialize_PointerTo_ns2__executeSqlEx(soap, (struct _ns2__executeSqlEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeUpdateResponse:
		soap_serialize_PointerTo_ns2__executeUpdateResponse(soap, (struct _ns2__executeUpdateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeUpdate:
		soap_serialize_PointerTo_ns2__executeUpdate(soap, (struct _ns2__executeUpdate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeSqlResponse:
		soap_serialize_PointerTo_ns2__executeSqlResponse(soap, (struct _ns2__executeSqlResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns2__executeSql:
		soap_serialize_PointerTo_ns2__executeSql(soap, (struct _ns2__executeSql *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse:
		soap_serialize_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse(soap, (struct _ns1__GetVpdnOnlineIPByImsiResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVpdnOnlineIPByImsi:
		soap_serialize_PointerTo_ns1__GetVpdnOnlineIPByImsi(soap, (struct _ns1__GetVpdnOnlineIPByImsi *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVpdnIPByImsiResponse:
		soap_serialize_PointerTo_ns1__GetVpdnIPByImsiResponse(soap, (struct _ns1__GetVpdnIPByImsiResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVpdnIPByImsi:
		soap_serialize_PointerTo_ns1__GetVpdnIPByImsi(soap, (struct _ns1__GetVpdnIPByImsi *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VpdnOnlineIPResponse:
		soap_serialize_PointerTons1__VpdnOnlineIPResponse(soap, (struct ns1__VpdnOnlineIPResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VpdnOnlineIPRequest:
		soap_serialize_PointerTons1__VpdnOnlineIPRequest(soap, (struct ns1__VpdnOnlineIPRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VpdnIPResponse:
		soap_serialize_PointerTons1__VpdnIPResponse(soap, (struct ns1__VpdnIPResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__VpdnIPRequest:
		soap_serialize_PointerTons1__VpdnIPRequest(soap, (struct ns1__VpdnIPRequest *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__call(struct soap *soap, struct __ns2__call *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__call = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__call(struct soap *soap, const struct __ns2__call *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__call(soap, &a->ns2__call);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__call(struct soap *soap, const char *tag, int id, const struct __ns2__call *a, const char *type)
{
	if (soap_out_PointerTo_ns2__call(soap, "ns2:call", -1, &a->ns2__call, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__call * SOAP_FMAC4 soap_in___ns2__call(struct soap *soap, const char *tag, struct __ns2__call *a, const char *type)
{
	size_t soap_flag_ns2__call = 1;
	short soap_flag;
	a = (struct __ns2__call *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__call, sizeof(struct __ns2__call), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__call(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__call && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__call(soap, "ns2:call", &a->ns2__call, ""))
				{	soap_flag_ns2__call--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__call(struct soap *soap, const struct __ns2__call *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__call(soap, tag?tag:"-ns2:call", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__call * SOAP_FMAC4 soap_get___ns2__call(struct soap *soap, struct __ns2__call *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__call(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__executeXML(struct soap *soap, struct __ns2__executeXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__executeXML = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__executeXML(struct soap *soap, const struct __ns2__executeXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__executeXML(soap, &a->ns2__executeXML);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__executeXML(struct soap *soap, const char *tag, int id, const struct __ns2__executeXML *a, const char *type)
{
	if (soap_out_PointerTo_ns2__executeXML(soap, "ns2:executeXML", -1, &a->ns2__executeXML, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeXML * SOAP_FMAC4 soap_in___ns2__executeXML(struct soap *soap, const char *tag, struct __ns2__executeXML *a, const char *type)
{
	size_t soap_flag_ns2__executeXML = 1;
	short soap_flag;
	a = (struct __ns2__executeXML *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__executeXML, sizeof(struct __ns2__executeXML), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__executeXML(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__executeXML && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__executeXML(soap, "ns2:executeXML", &a->ns2__executeXML, ""))
				{	soap_flag_ns2__executeXML--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__executeXML(struct soap *soap, const struct __ns2__executeXML *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__executeXML(soap, tag?tag:"-ns2:executeXML", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeXML * SOAP_FMAC4 soap_get___ns2__executeXML(struct soap *soap, struct __ns2__executeXML *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__executeXML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__executeQueryOra(struct soap *soap, struct __ns2__executeQueryOra *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__executeQueryOra = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__executeQueryOra(struct soap *soap, const struct __ns2__executeQueryOra *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__executeQueryOra(soap, &a->ns2__executeQueryOra);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__executeQueryOra(struct soap *soap, const char *tag, int id, const struct __ns2__executeQueryOra *a, const char *type)
{
	if (soap_out_PointerTo_ns2__executeQueryOra(soap, "ns2:executeQueryOra", -1, &a->ns2__executeQueryOra, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeQueryOra * SOAP_FMAC4 soap_in___ns2__executeQueryOra(struct soap *soap, const char *tag, struct __ns2__executeQueryOra *a, const char *type)
{
	size_t soap_flag_ns2__executeQueryOra = 1;
	short soap_flag;
	a = (struct __ns2__executeQueryOra *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__executeQueryOra, sizeof(struct __ns2__executeQueryOra), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__executeQueryOra(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__executeQueryOra && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__executeQueryOra(soap, "ns2:executeQueryOra", &a->ns2__executeQueryOra, ""))
				{	soap_flag_ns2__executeQueryOra--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__executeQueryOra(struct soap *soap, const struct __ns2__executeQueryOra *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__executeQueryOra(soap, tag?tag:"-ns2:executeQueryOra", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeQueryOra * SOAP_FMAC4 soap_get___ns2__executeQueryOra(struct soap *soap, struct __ns2__executeQueryOra *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__executeQueryOra(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__executeProcedure(struct soap *soap, struct __ns2__executeProcedure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__executeProcedure = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__executeProcedure(struct soap *soap, const struct __ns2__executeProcedure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__executeProcedure(soap, &a->ns2__executeProcedure);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__executeProcedure(struct soap *soap, const char *tag, int id, const struct __ns2__executeProcedure *a, const char *type)
{
	if (soap_out_PointerTo_ns2__executeProcedure(soap, "ns2:executeProcedure", -1, &a->ns2__executeProcedure, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeProcedure * SOAP_FMAC4 soap_in___ns2__executeProcedure(struct soap *soap, const char *tag, struct __ns2__executeProcedure *a, const char *type)
{
	size_t soap_flag_ns2__executeProcedure = 1;
	short soap_flag;
	a = (struct __ns2__executeProcedure *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__executeProcedure, sizeof(struct __ns2__executeProcedure), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__executeProcedure(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__executeProcedure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__executeProcedure(soap, "ns2:executeProcedure", &a->ns2__executeProcedure, ""))
				{	soap_flag_ns2__executeProcedure--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__executeProcedure(struct soap *soap, const struct __ns2__executeProcedure *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__executeProcedure(soap, tag?tag:"-ns2:executeProcedure", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeProcedure * SOAP_FMAC4 soap_get___ns2__executeProcedure(struct soap *soap, struct __ns2__executeProcedure *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__executeProcedure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__executeQueryEx(struct soap *soap, struct __ns2__executeQueryEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__executeQueryEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__executeQueryEx(struct soap *soap, const struct __ns2__executeQueryEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__executeQueryEx(soap, &a->ns2__executeQueryEx);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__executeQueryEx(struct soap *soap, const char *tag, int id, const struct __ns2__executeQueryEx *a, const char *type)
{
	if (soap_out_PointerTo_ns2__executeQueryEx(soap, "ns2:executeQueryEx", -1, &a->ns2__executeQueryEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeQueryEx * SOAP_FMAC4 soap_in___ns2__executeQueryEx(struct soap *soap, const char *tag, struct __ns2__executeQueryEx *a, const char *type)
{
	size_t soap_flag_ns2__executeQueryEx = 1;
	short soap_flag;
	a = (struct __ns2__executeQueryEx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__executeQueryEx, sizeof(struct __ns2__executeQueryEx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__executeQueryEx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__executeQueryEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__executeQueryEx(soap, "ns2:executeQueryEx", &a->ns2__executeQueryEx, ""))
				{	soap_flag_ns2__executeQueryEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__executeQueryEx(struct soap *soap, const struct __ns2__executeQueryEx *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__executeQueryEx(soap, tag?tag:"-ns2:executeQueryEx", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeQueryEx * SOAP_FMAC4 soap_get___ns2__executeQueryEx(struct soap *soap, struct __ns2__executeQueryEx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__executeQueryEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__executeQuery(struct soap *soap, struct __ns2__executeQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__executeQuery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__executeQuery(struct soap *soap, const struct __ns2__executeQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__executeQuery(soap, &a->ns2__executeQuery);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__executeQuery(struct soap *soap, const char *tag, int id, const struct __ns2__executeQuery *a, const char *type)
{
	if (soap_out_PointerTo_ns2__executeQuery(soap, "ns2:executeQuery", -1, &a->ns2__executeQuery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeQuery * SOAP_FMAC4 soap_in___ns2__executeQuery(struct soap *soap, const char *tag, struct __ns2__executeQuery *a, const char *type)
{
	size_t soap_flag_ns2__executeQuery = 1;
	short soap_flag;
	a = (struct __ns2__executeQuery *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__executeQuery, sizeof(struct __ns2__executeQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__executeQuery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__executeQuery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__executeQuery(soap, "ns2:executeQuery", &a->ns2__executeQuery, ""))
				{	soap_flag_ns2__executeQuery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__executeQuery(struct soap *soap, const struct __ns2__executeQuery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__executeQuery(soap, tag?tag:"-ns2:executeQuery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeQuery * SOAP_FMAC4 soap_get___ns2__executeQuery(struct soap *soap, struct __ns2__executeQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__executeQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__executeProcedureEx(struct soap *soap, struct __ns2__executeProcedureEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__executeProcedureEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__executeProcedureEx(struct soap *soap, const struct __ns2__executeProcedureEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__executeProcedureEx(soap, &a->ns2__executeProcedureEx);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__executeProcedureEx(struct soap *soap, const char *tag, int id, const struct __ns2__executeProcedureEx *a, const char *type)
{
	if (soap_out_PointerTo_ns2__executeProcedureEx(soap, "ns2:executeProcedureEx", -1, &a->ns2__executeProcedureEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeProcedureEx * SOAP_FMAC4 soap_in___ns2__executeProcedureEx(struct soap *soap, const char *tag, struct __ns2__executeProcedureEx *a, const char *type)
{
	size_t soap_flag_ns2__executeProcedureEx = 1;
	short soap_flag;
	a = (struct __ns2__executeProcedureEx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__executeProcedureEx, sizeof(struct __ns2__executeProcedureEx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__executeProcedureEx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__executeProcedureEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__executeProcedureEx(soap, "ns2:executeProcedureEx", &a->ns2__executeProcedureEx, ""))
				{	soap_flag_ns2__executeProcedureEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__executeProcedureEx(struct soap *soap, const struct __ns2__executeProcedureEx *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__executeProcedureEx(soap, tag?tag:"-ns2:executeProcedureEx", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeProcedureEx * SOAP_FMAC4 soap_get___ns2__executeProcedureEx(struct soap *soap, struct __ns2__executeProcedureEx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__executeProcedureEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__executeSqlEx(struct soap *soap, struct __ns2__executeSqlEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__executeSqlEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__executeSqlEx(struct soap *soap, const struct __ns2__executeSqlEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__executeSqlEx(soap, &a->ns2__executeSqlEx);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__executeSqlEx(struct soap *soap, const char *tag, int id, const struct __ns2__executeSqlEx *a, const char *type)
{
	if (soap_out_PointerTo_ns2__executeSqlEx(soap, "ns2:executeSqlEx", -1, &a->ns2__executeSqlEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeSqlEx * SOAP_FMAC4 soap_in___ns2__executeSqlEx(struct soap *soap, const char *tag, struct __ns2__executeSqlEx *a, const char *type)
{
	size_t soap_flag_ns2__executeSqlEx = 1;
	short soap_flag;
	a = (struct __ns2__executeSqlEx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__executeSqlEx, sizeof(struct __ns2__executeSqlEx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__executeSqlEx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__executeSqlEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__executeSqlEx(soap, "ns2:executeSqlEx", &a->ns2__executeSqlEx, ""))
				{	soap_flag_ns2__executeSqlEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__executeSqlEx(struct soap *soap, const struct __ns2__executeSqlEx *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__executeSqlEx(soap, tag?tag:"-ns2:executeSqlEx", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeSqlEx * SOAP_FMAC4 soap_get___ns2__executeSqlEx(struct soap *soap, struct __ns2__executeSqlEx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__executeSqlEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__executeUpdate(struct soap *soap, struct __ns2__executeUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__executeUpdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__executeUpdate(struct soap *soap, const struct __ns2__executeUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__executeUpdate(soap, &a->ns2__executeUpdate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__executeUpdate(struct soap *soap, const char *tag, int id, const struct __ns2__executeUpdate *a, const char *type)
{
	if (soap_out_PointerTo_ns2__executeUpdate(soap, "ns2:executeUpdate", -1, &a->ns2__executeUpdate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeUpdate * SOAP_FMAC4 soap_in___ns2__executeUpdate(struct soap *soap, const char *tag, struct __ns2__executeUpdate *a, const char *type)
{
	size_t soap_flag_ns2__executeUpdate = 1;
	short soap_flag;
	a = (struct __ns2__executeUpdate *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__executeUpdate, sizeof(struct __ns2__executeUpdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__executeUpdate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__executeUpdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__executeUpdate(soap, "ns2:executeUpdate", &a->ns2__executeUpdate, ""))
				{	soap_flag_ns2__executeUpdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__executeUpdate(struct soap *soap, const struct __ns2__executeUpdate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__executeUpdate(soap, tag?tag:"-ns2:executeUpdate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeUpdate * SOAP_FMAC4 soap_get___ns2__executeUpdate(struct soap *soap, struct __ns2__executeUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__executeUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns2__executeSql(struct soap *soap, struct __ns2__executeSql *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns2__executeSql = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns2__executeSql(struct soap *soap, const struct __ns2__executeSql *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns2__executeSql(soap, &a->ns2__executeSql);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns2__executeSql(struct soap *soap, const char *tag, int id, const struct __ns2__executeSql *a, const char *type)
{
	if (soap_out_PointerTo_ns2__executeSql(soap, "ns2:executeSql", -1, &a->ns2__executeSql, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeSql * SOAP_FMAC4 soap_in___ns2__executeSql(struct soap *soap, const char *tag, struct __ns2__executeSql *a, const char *type)
{
	size_t soap_flag_ns2__executeSql = 1;
	short soap_flag;
	a = (struct __ns2__executeSql *)soap_id_enter(soap, "", a, SOAP_TYPE___ns2__executeSql, sizeof(struct __ns2__executeSql), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns2__executeSql(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns2__executeSql && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns2__executeSql(soap, "ns2:executeSql", &a->ns2__executeSql, ""))
				{	soap_flag_ns2__executeSql--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns2__executeSql(struct soap *soap, const struct __ns2__executeSql *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns2__executeSql(soap, tag?tag:"-ns2:executeSql", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns2__executeSql * SOAP_FMAC4 soap_get___ns2__executeSql(struct soap *soap, struct __ns2__executeSql *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns2__executeSql(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetVpdnOnlineIPByImsi(struct soap *soap, struct __ns1__GetVpdnOnlineIPByImsi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetVpdnOnlineIPByImsi = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetVpdnOnlineIPByImsi(struct soap *soap, const struct __ns1__GetVpdnOnlineIPByImsi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetVpdnOnlineIPByImsi(soap, &a->ns1__GetVpdnOnlineIPByImsi);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetVpdnOnlineIPByImsi(struct soap *soap, const char *tag, int id, const struct __ns1__GetVpdnOnlineIPByImsi *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetVpdnOnlineIPByImsi(soap, "ns1:GetVpdnOnlineIPByImsi", -1, &a->ns1__GetVpdnOnlineIPByImsi, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVpdnOnlineIPByImsi * SOAP_FMAC4 soap_in___ns1__GetVpdnOnlineIPByImsi(struct soap *soap, const char *tag, struct __ns1__GetVpdnOnlineIPByImsi *a, const char *type)
{
	size_t soap_flag_ns1__GetVpdnOnlineIPByImsi = 1;
	short soap_flag;
	a = (struct __ns1__GetVpdnOnlineIPByImsi *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetVpdnOnlineIPByImsi, sizeof(struct __ns1__GetVpdnOnlineIPByImsi), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetVpdnOnlineIPByImsi(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetVpdnOnlineIPByImsi && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetVpdnOnlineIPByImsi(soap, "ns1:GetVpdnOnlineIPByImsi", &a->ns1__GetVpdnOnlineIPByImsi, ""))
				{	soap_flag_ns1__GetVpdnOnlineIPByImsi--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetVpdnOnlineIPByImsi(struct soap *soap, const struct __ns1__GetVpdnOnlineIPByImsi *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetVpdnOnlineIPByImsi(soap, tag?tag:"-ns1:GetVpdnOnlineIPByImsi", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVpdnOnlineIPByImsi * SOAP_FMAC4 soap_get___ns1__GetVpdnOnlineIPByImsi(struct soap *soap, struct __ns1__GetVpdnOnlineIPByImsi *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetVpdnOnlineIPByImsi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetVpdnIPByImsi(struct soap *soap, struct __ns1__GetVpdnIPByImsi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetVpdnIPByImsi = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetVpdnIPByImsi(struct soap *soap, const struct __ns1__GetVpdnIPByImsi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetVpdnIPByImsi(soap, &a->ns1__GetVpdnIPByImsi);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetVpdnIPByImsi(struct soap *soap, const char *tag, int id, const struct __ns1__GetVpdnIPByImsi *a, const char *type)
{
	if (soap_out_PointerTo_ns1__GetVpdnIPByImsi(soap, "ns1:GetVpdnIPByImsi", -1, &a->ns1__GetVpdnIPByImsi, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVpdnIPByImsi * SOAP_FMAC4 soap_in___ns1__GetVpdnIPByImsi(struct soap *soap, const char *tag, struct __ns1__GetVpdnIPByImsi *a, const char *type)
{
	size_t soap_flag_ns1__GetVpdnIPByImsi = 1;
	short soap_flag;
	a = (struct __ns1__GetVpdnIPByImsi *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetVpdnIPByImsi, sizeof(struct __ns1__GetVpdnIPByImsi), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetVpdnIPByImsi(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetVpdnIPByImsi && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetVpdnIPByImsi(soap, "ns1:GetVpdnIPByImsi", &a->ns1__GetVpdnIPByImsi, ""))
				{	soap_flag_ns1__GetVpdnIPByImsi--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetVpdnIPByImsi(struct soap *soap, const struct __ns1__GetVpdnIPByImsi *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetVpdnIPByImsi(soap, tag?tag:"-ns1:GetVpdnIPByImsi", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVpdnIPByImsi * SOAP_FMAC4 soap_get___ns1__GetVpdnIPByImsi(struct soap *soap, struct __ns1__GetVpdnIPByImsi *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetVpdnIPByImsi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__callResponse(struct soap *soap, struct _ns2__callResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->callReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__callResponse(struct soap *soap, const struct _ns2__callResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->callReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__callResponse(struct soap *soap, const char *tag, int id, const struct _ns2__callResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__callResponse), type))
		return soap->error;
	if (a->callReturn)
		soap_element_result(soap, "ns2:callReturn");
	if (soap_out_string(soap, "ns2:callReturn", -1, &a->callReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__callResponse * SOAP_FMAC4 soap_in__ns2__callResponse(struct soap *soap, const char *tag, struct _ns2__callResponse *a, const char *type)
{
	size_t soap_flag_callReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__callResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__callResponse, sizeof(struct _ns2__callResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__callResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_callReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:callReturn", &a->callReturn, "xsd:string"))
				{	soap_flag_callReturn--;
					continue;
				}
			soap_check_result(soap, "ns2:callReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__callResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__callResponse, 0, sizeof(struct _ns2__callResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__callResponse(struct soap *soap, const struct _ns2__callResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__callResponse);
	if (soap_out__ns2__callResponse(soap, tag?tag:"ns2:callResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__callResponse * SOAP_FMAC4 soap_get__ns2__callResponse(struct soap *soap, struct _ns2__callResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__callResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__call(struct soap *soap, struct _ns2__call *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->inXmlString);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__call(struct soap *soap, const struct _ns2__call *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->inXmlString);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__call(struct soap *soap, const char *tag, int id, const struct _ns2__call *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__call), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:inXmlString", -1, &a->inXmlString, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__call * SOAP_FMAC4 soap_in__ns2__call(struct soap *soap, const char *tag, struct _ns2__call *a, const char *type)
{
	size_t soap_flag_inXmlString = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__call *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__call, sizeof(struct _ns2__call), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__call(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inXmlString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:inXmlString", &a->inXmlString, "xsd:string"))
				{	soap_flag_inXmlString--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__call *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__call, 0, sizeof(struct _ns2__call), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__call(struct soap *soap, const struct _ns2__call *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__call);
	if (soap_out__ns2__call(soap, tag?tag:"ns2:call", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__call * SOAP_FMAC4 soap_get__ns2__call(struct soap *soap, struct _ns2__call *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__call(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeXMLResponse(struct soap *soap, struct _ns2__executeXMLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->executeXMLReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeXMLResponse(struct soap *soap, const struct _ns2__executeXMLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->executeXMLReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeXMLResponse(struct soap *soap, const char *tag, int id, const struct _ns2__executeXMLResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeXMLResponse), type))
		return soap->error;
	if (a->executeXMLReturn)
		soap_element_result(soap, "ns2:executeXMLReturn");
	if (soap_out_string(soap, "ns2:executeXMLReturn", -1, &a->executeXMLReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeXMLResponse * SOAP_FMAC4 soap_in__ns2__executeXMLResponse(struct soap *soap, const char *tag, struct _ns2__executeXMLResponse *a, const char *type)
{
	size_t soap_flag_executeXMLReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeXMLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeXMLResponse, sizeof(struct _ns2__executeXMLResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeXMLResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executeXMLReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:executeXMLReturn", &a->executeXMLReturn, "xsd:string"))
				{	soap_flag_executeXMLReturn--;
					continue;
				}
			soap_check_result(soap, "ns2:executeXMLReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeXMLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeXMLResponse, 0, sizeof(struct _ns2__executeXMLResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeXMLResponse(struct soap *soap, const struct _ns2__executeXMLResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeXMLResponse);
	if (soap_out__ns2__executeXMLResponse(soap, tag?tag:"ns2:executeXMLResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeXMLResponse * SOAP_FMAC4 soap_get__ns2__executeXMLResponse(struct soap *soap, struct _ns2__executeXMLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeXMLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeXML(struct soap *soap, struct _ns2__executeXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->inXmlString);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeXML(struct soap *soap, const struct _ns2__executeXML *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->inXmlString);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeXML(struct soap *soap, const char *tag, int id, const struct _ns2__executeXML *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeXML), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:inXmlString", -1, &a->inXmlString, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeXML * SOAP_FMAC4 soap_in__ns2__executeXML(struct soap *soap, const char *tag, struct _ns2__executeXML *a, const char *type)
{
	size_t soap_flag_inXmlString = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeXML *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeXML, sizeof(struct _ns2__executeXML), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeXML(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inXmlString && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:inXmlString", &a->inXmlString, "xsd:string"))
				{	soap_flag_inXmlString--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeXML *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeXML, 0, sizeof(struct _ns2__executeXML), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeXML(struct soap *soap, const struct _ns2__executeXML *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeXML);
	if (soap_out__ns2__executeXML(soap, tag?tag:"ns2:executeXML", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeXML * SOAP_FMAC4 soap_get__ns2__executeXML(struct soap *soap, struct _ns2__executeXML *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeXML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeQueryOraResponse(struct soap *soap, struct _ns2__executeQueryOraResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->executeQueryOraReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeQueryOraResponse(struct soap *soap, const struct _ns2__executeQueryOraResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->executeQueryOraReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeQueryOraResponse(struct soap *soap, const char *tag, int id, const struct _ns2__executeQueryOraResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeQueryOraResponse), type))
		return soap->error;
	if (a->executeQueryOraReturn)
		soap_element_result(soap, "ns2:executeQueryOraReturn");
	if (soap_out_string(soap, "ns2:executeQueryOraReturn", -1, &a->executeQueryOraReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeQueryOraResponse * SOAP_FMAC4 soap_in__ns2__executeQueryOraResponse(struct soap *soap, const char *tag, struct _ns2__executeQueryOraResponse *a, const char *type)
{
	size_t soap_flag_executeQueryOraReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeQueryOraResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeQueryOraResponse, sizeof(struct _ns2__executeQueryOraResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeQueryOraResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executeQueryOraReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:executeQueryOraReturn", &a->executeQueryOraReturn, "xsd:string"))
				{	soap_flag_executeQueryOraReturn--;
					continue;
				}
			soap_check_result(soap, "ns2:executeQueryOraReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQueryOraResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeQueryOraResponse, 0, sizeof(struct _ns2__executeQueryOraResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeQueryOraResponse(struct soap *soap, const struct _ns2__executeQueryOraResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeQueryOraResponse);
	if (soap_out__ns2__executeQueryOraResponse(soap, tag?tag:"ns2:executeQueryOraResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQueryOraResponse * SOAP_FMAC4 soap_get__ns2__executeQueryOraResponse(struct soap *soap, struct _ns2__executeQueryOraResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeQueryOraResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeQueryOra(struct soap *soap, struct _ns2__executeQueryOra *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sql);
	soap_default_int(soap, &a->pageSize);
	soap_default_int(soap, &a->nowPage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeQueryOra(struct soap *soap, const struct _ns2__executeQueryOra *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sql);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeQueryOra(struct soap *soap, const char *tag, int id, const struct _ns2__executeQueryOra *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeQueryOra), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:sql", -1, &a->sql, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:pageSize", -1, &a->pageSize, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:nowPage", -1, &a->nowPage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeQueryOra * SOAP_FMAC4 soap_in__ns2__executeQueryOra(struct soap *soap, const char *tag, struct _ns2__executeQueryOra *a, const char *type)
{
	size_t soap_flag_sql = 1;
	size_t soap_flag_pageSize = 1;
	size_t soap_flag_nowPage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeQueryOra *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeQueryOra, sizeof(struct _ns2__executeQueryOra), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeQueryOra(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sql", &a->sql, "xsd:string"))
				{	soap_flag_sql--;
					continue;
				}
			if (soap_flag_pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:pageSize", &a->pageSize, "xsd:int"))
				{	soap_flag_pageSize--;
					continue;
				}
			if (soap_flag_nowPage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:nowPage", &a->nowPage, "xsd:int"))
				{	soap_flag_nowPage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQueryOra *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeQueryOra, 0, sizeof(struct _ns2__executeQueryOra), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pageSize > 0 || soap_flag_nowPage > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeQueryOra(struct soap *soap, const struct _ns2__executeQueryOra *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeQueryOra);
	if (soap_out__ns2__executeQueryOra(soap, tag?tag:"ns2:executeQueryOra", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQueryOra * SOAP_FMAC4 soap_get__ns2__executeQueryOra(struct soap *soap, struct _ns2__executeQueryOra *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeQueryOra(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeProcedureResponse(struct soap *soap, struct _ns2__executeProcedureResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->executeProcedureReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeProcedureResponse(struct soap *soap, const struct _ns2__executeProcedureResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->executeProcedureReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeProcedureResponse(struct soap *soap, const char *tag, int id, const struct _ns2__executeProcedureResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeProcedureResponse), type))
		return soap->error;
	if (a->executeProcedureReturn)
		soap_element_result(soap, "ns2:executeProcedureReturn");
	if (soap_out_string(soap, "ns2:executeProcedureReturn", -1, &a->executeProcedureReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeProcedureResponse * SOAP_FMAC4 soap_in__ns2__executeProcedureResponse(struct soap *soap, const char *tag, struct _ns2__executeProcedureResponse *a, const char *type)
{
	size_t soap_flag_executeProcedureReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeProcedureResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeProcedureResponse, sizeof(struct _ns2__executeProcedureResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeProcedureResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executeProcedureReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:executeProcedureReturn", &a->executeProcedureReturn, "xsd:string"))
				{	soap_flag_executeProcedureReturn--;
					continue;
				}
			soap_check_result(soap, "ns2:executeProcedureReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeProcedureResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeProcedureResponse, 0, sizeof(struct _ns2__executeProcedureResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeProcedureResponse(struct soap *soap, const struct _ns2__executeProcedureResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeProcedureResponse);
	if (soap_out__ns2__executeProcedureResponse(soap, tag?tag:"ns2:executeProcedureResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeProcedureResponse * SOAP_FMAC4 soap_get__ns2__executeProcedureResponse(struct soap *soap, struct _ns2__executeProcedureResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeProcedureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeProcedure(struct soap *soap, struct _ns2__executeProcedure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sql);
	soap_default_string(soap, &a->sqlParam);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeProcedure(struct soap *soap, const struct _ns2__executeProcedure *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sql);
	soap_serialize_string(soap, &a->sqlParam);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeProcedure(struct soap *soap, const char *tag, int id, const struct _ns2__executeProcedure *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeProcedure), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:sql", -1, &a->sql, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:sqlParam", -1, &a->sqlParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeProcedure * SOAP_FMAC4 soap_in__ns2__executeProcedure(struct soap *soap, const char *tag, struct _ns2__executeProcedure *a, const char *type)
{
	size_t soap_flag_sql = 1;
	size_t soap_flag_sqlParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeProcedure *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeProcedure, sizeof(struct _ns2__executeProcedure), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeProcedure(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sql", &a->sql, "xsd:string"))
				{	soap_flag_sql--;
					continue;
				}
			if (soap_flag_sqlParam && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sqlParam", &a->sqlParam, "xsd:string"))
				{	soap_flag_sqlParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeProcedure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeProcedure, 0, sizeof(struct _ns2__executeProcedure), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeProcedure(struct soap *soap, const struct _ns2__executeProcedure *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeProcedure);
	if (soap_out__ns2__executeProcedure(soap, tag?tag:"ns2:executeProcedure", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeProcedure * SOAP_FMAC4 soap_get__ns2__executeProcedure(struct soap *soap, struct _ns2__executeProcedure *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeProcedure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeQueryExResponse(struct soap *soap, struct _ns2__executeQueryExResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->executeQueryExReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeQueryExResponse(struct soap *soap, const struct _ns2__executeQueryExResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->executeQueryExReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeQueryExResponse(struct soap *soap, const char *tag, int id, const struct _ns2__executeQueryExResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeQueryExResponse), type))
		return soap->error;
	if (a->executeQueryExReturn)
		soap_element_result(soap, "ns2:executeQueryExReturn");
	if (soap_out_string(soap, "ns2:executeQueryExReturn", -1, &a->executeQueryExReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeQueryExResponse * SOAP_FMAC4 soap_in__ns2__executeQueryExResponse(struct soap *soap, const char *tag, struct _ns2__executeQueryExResponse *a, const char *type)
{
	size_t soap_flag_executeQueryExReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeQueryExResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeQueryExResponse, sizeof(struct _ns2__executeQueryExResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeQueryExResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executeQueryExReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:executeQueryExReturn", &a->executeQueryExReturn, "xsd:string"))
				{	soap_flag_executeQueryExReturn--;
					continue;
				}
			soap_check_result(soap, "ns2:executeQueryExReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQueryExResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeQueryExResponse, 0, sizeof(struct _ns2__executeQueryExResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeQueryExResponse(struct soap *soap, const struct _ns2__executeQueryExResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeQueryExResponse);
	if (soap_out__ns2__executeQueryExResponse(soap, tag?tag:"ns2:executeQueryExResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQueryExResponse * SOAP_FMAC4 soap_get__ns2__executeQueryExResponse(struct soap *soap, struct _ns2__executeQueryExResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeQueryExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeQueryEx(struct soap *soap, struct _ns2__executeQueryEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sql);
	soap_default_int(soap, &a->pageSize);
	soap_default_int(soap, &a->nowPage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeQueryEx(struct soap *soap, const struct _ns2__executeQueryEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sql);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeQueryEx(struct soap *soap, const char *tag, int id, const struct _ns2__executeQueryEx *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeQueryEx), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:sql", -1, &a->sql, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:pageSize", -1, &a->pageSize, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:nowPage", -1, &a->nowPage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeQueryEx * SOAP_FMAC4 soap_in__ns2__executeQueryEx(struct soap *soap, const char *tag, struct _ns2__executeQueryEx *a, const char *type)
{
	size_t soap_flag_sql = 1;
	size_t soap_flag_pageSize = 1;
	size_t soap_flag_nowPage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeQueryEx *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeQueryEx, sizeof(struct _ns2__executeQueryEx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeQueryEx(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sql", &a->sql, "xsd:string"))
				{	soap_flag_sql--;
					continue;
				}
			if (soap_flag_pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:pageSize", &a->pageSize, "xsd:int"))
				{	soap_flag_pageSize--;
					continue;
				}
			if (soap_flag_nowPage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:nowPage", &a->nowPage, "xsd:int"))
				{	soap_flag_nowPage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQueryEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeQueryEx, 0, sizeof(struct _ns2__executeQueryEx), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pageSize > 0 || soap_flag_nowPage > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeQueryEx(struct soap *soap, const struct _ns2__executeQueryEx *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeQueryEx);
	if (soap_out__ns2__executeQueryEx(soap, tag?tag:"ns2:executeQueryEx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQueryEx * SOAP_FMAC4 soap_get__ns2__executeQueryEx(struct soap *soap, struct _ns2__executeQueryEx *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeQueryEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeQueryResponse(struct soap *soap, struct _ns2__executeQueryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->executeQueryReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeQueryResponse(struct soap *soap, const struct _ns2__executeQueryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->executeQueryReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeQueryResponse(struct soap *soap, const char *tag, int id, const struct _ns2__executeQueryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeQueryResponse), type))
		return soap->error;
	if (a->executeQueryReturn)
		soap_element_result(soap, "ns2:executeQueryReturn");
	if (soap_out_string(soap, "ns2:executeQueryReturn", -1, &a->executeQueryReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeQueryResponse * SOAP_FMAC4 soap_in__ns2__executeQueryResponse(struct soap *soap, const char *tag, struct _ns2__executeQueryResponse *a, const char *type)
{
	size_t soap_flag_executeQueryReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeQueryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeQueryResponse, sizeof(struct _ns2__executeQueryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeQueryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executeQueryReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:executeQueryReturn", &a->executeQueryReturn, "xsd:string"))
				{	soap_flag_executeQueryReturn--;
					continue;
				}
			soap_check_result(soap, "ns2:executeQueryReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQueryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeQueryResponse, 0, sizeof(struct _ns2__executeQueryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeQueryResponse(struct soap *soap, const struct _ns2__executeQueryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeQueryResponse);
	if (soap_out__ns2__executeQueryResponse(soap, tag?tag:"ns2:executeQueryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQueryResponse * SOAP_FMAC4 soap_get__ns2__executeQueryResponse(struct soap *soap, struct _ns2__executeQueryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeQuery(struct soap *soap, struct _ns2__executeQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sql);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeQuery(struct soap *soap, const struct _ns2__executeQuery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sql);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeQuery(struct soap *soap, const char *tag, int id, const struct _ns2__executeQuery *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeQuery), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:sql", -1, &a->sql, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeQuery * SOAP_FMAC4 soap_in__ns2__executeQuery(struct soap *soap, const char *tag, struct _ns2__executeQuery *a, const char *type)
{
	size_t soap_flag_sql = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeQuery *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeQuery, sizeof(struct _ns2__executeQuery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeQuery(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sql", &a->sql, "xsd:string"))
				{	soap_flag_sql--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQuery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeQuery, 0, sizeof(struct _ns2__executeQuery), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeQuery(struct soap *soap, const struct _ns2__executeQuery *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeQuery);
	if (soap_out__ns2__executeQuery(soap, tag?tag:"ns2:executeQuery", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQuery * SOAP_FMAC4 soap_get__ns2__executeQuery(struct soap *soap, struct _ns2__executeQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeProcedureExResponse(struct soap *soap, struct _ns2__executeProcedureExResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->executeProcedureExReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeProcedureExResponse(struct soap *soap, const struct _ns2__executeProcedureExResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->executeProcedureExReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeProcedureExResponse(struct soap *soap, const char *tag, int id, const struct _ns2__executeProcedureExResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeProcedureExResponse), type))
		return soap->error;
	if (a->executeProcedureExReturn)
		soap_element_result(soap, "ns2:executeProcedureExReturn");
	if (soap_out_string(soap, "ns2:executeProcedureExReturn", -1, &a->executeProcedureExReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeProcedureExResponse * SOAP_FMAC4 soap_in__ns2__executeProcedureExResponse(struct soap *soap, const char *tag, struct _ns2__executeProcedureExResponse *a, const char *type)
{
	size_t soap_flag_executeProcedureExReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeProcedureExResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeProcedureExResponse, sizeof(struct _ns2__executeProcedureExResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeProcedureExResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executeProcedureExReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:executeProcedureExReturn", &a->executeProcedureExReturn, "xsd:string"))
				{	soap_flag_executeProcedureExReturn--;
					continue;
				}
			soap_check_result(soap, "ns2:executeProcedureExReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeProcedureExResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeProcedureExResponse, 0, sizeof(struct _ns2__executeProcedureExResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeProcedureExResponse(struct soap *soap, const struct _ns2__executeProcedureExResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeProcedureExResponse);
	if (soap_out__ns2__executeProcedureExResponse(soap, tag?tag:"ns2:executeProcedureExResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeProcedureExResponse * SOAP_FMAC4 soap_get__ns2__executeProcedureExResponse(struct soap *soap, struct _ns2__executeProcedureExResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeProcedureExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeProcedureEx(struct soap *soap, struct _ns2__executeProcedureEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sql);
	soap_default_string(soap, &a->sqlParam);
	soap_default_int(soap, &a->pageSize);
	soap_default_int(soap, &a->nowPage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeProcedureEx(struct soap *soap, const struct _ns2__executeProcedureEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sql);
	soap_serialize_string(soap, &a->sqlParam);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeProcedureEx(struct soap *soap, const char *tag, int id, const struct _ns2__executeProcedureEx *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeProcedureEx), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:sql", -1, &a->sql, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:sqlParam", -1, &a->sqlParam, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:pageSize", -1, &a->pageSize, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:nowPage", -1, &a->nowPage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeProcedureEx * SOAP_FMAC4 soap_in__ns2__executeProcedureEx(struct soap *soap, const char *tag, struct _ns2__executeProcedureEx *a, const char *type)
{
	size_t soap_flag_sql = 1;
	size_t soap_flag_sqlParam = 1;
	size_t soap_flag_pageSize = 1;
	size_t soap_flag_nowPage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeProcedureEx *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeProcedureEx, sizeof(struct _ns2__executeProcedureEx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeProcedureEx(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sql", &a->sql, "xsd:string"))
				{	soap_flag_sql--;
					continue;
				}
			if (soap_flag_sqlParam && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sqlParam", &a->sqlParam, "xsd:string"))
				{	soap_flag_sqlParam--;
					continue;
				}
			if (soap_flag_pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:pageSize", &a->pageSize, "xsd:int"))
				{	soap_flag_pageSize--;
					continue;
				}
			if (soap_flag_nowPage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:nowPage", &a->nowPage, "xsd:int"))
				{	soap_flag_nowPage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeProcedureEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeProcedureEx, 0, sizeof(struct _ns2__executeProcedureEx), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pageSize > 0 || soap_flag_nowPage > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeProcedureEx(struct soap *soap, const struct _ns2__executeProcedureEx *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeProcedureEx);
	if (soap_out__ns2__executeProcedureEx(soap, tag?tag:"ns2:executeProcedureEx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeProcedureEx * SOAP_FMAC4 soap_get__ns2__executeProcedureEx(struct soap *soap, struct _ns2__executeProcedureEx *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeProcedureEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeSqlExResponse(struct soap *soap, struct _ns2__executeSqlExResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->executeSqlExReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeSqlExResponse(struct soap *soap, const struct _ns2__executeSqlExResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->executeSqlExReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeSqlExResponse(struct soap *soap, const char *tag, int id, const struct _ns2__executeSqlExResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeSqlExResponse), type))
		return soap->error;
	if (a->executeSqlExReturn)
		soap_element_result(soap, "ns2:executeSqlExReturn");
	if (soap_out_string(soap, "ns2:executeSqlExReturn", -1, &a->executeSqlExReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeSqlExResponse * SOAP_FMAC4 soap_in__ns2__executeSqlExResponse(struct soap *soap, const char *tag, struct _ns2__executeSqlExResponse *a, const char *type)
{
	size_t soap_flag_executeSqlExReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeSqlExResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeSqlExResponse, sizeof(struct _ns2__executeSqlExResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeSqlExResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executeSqlExReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:executeSqlExReturn", &a->executeSqlExReturn, "xsd:string"))
				{	soap_flag_executeSqlExReturn--;
					continue;
				}
			soap_check_result(soap, "ns2:executeSqlExReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeSqlExResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeSqlExResponse, 0, sizeof(struct _ns2__executeSqlExResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeSqlExResponse(struct soap *soap, const struct _ns2__executeSqlExResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeSqlExResponse);
	if (soap_out__ns2__executeSqlExResponse(soap, tag?tag:"ns2:executeSqlExResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeSqlExResponse * SOAP_FMAC4 soap_get__ns2__executeSqlExResponse(struct soap *soap, struct _ns2__executeSqlExResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeSqlExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeSqlEx(struct soap *soap, struct _ns2__executeSqlEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sqlId);
	soap_default_string(soap, &a->sqlParam);
	soap_default_int(soap, &a->pageSize);
	soap_default_int(soap, &a->Nowpage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeSqlEx(struct soap *soap, const struct _ns2__executeSqlEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sqlId);
	soap_serialize_string(soap, &a->sqlParam);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeSqlEx(struct soap *soap, const char *tag, int id, const struct _ns2__executeSqlEx *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeSqlEx), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:sqlId", -1, &a->sqlId, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:sqlParam", -1, &a->sqlParam, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:pageSize", -1, &a->pageSize, ""))
		return soap->error;
	if (soap_out_int(soap, "ns2:Nowpage", -1, &a->Nowpage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeSqlEx * SOAP_FMAC4 soap_in__ns2__executeSqlEx(struct soap *soap, const char *tag, struct _ns2__executeSqlEx *a, const char *type)
{
	size_t soap_flag_sqlId = 1;
	size_t soap_flag_sqlParam = 1;
	size_t soap_flag_pageSize = 1;
	size_t soap_flag_Nowpage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeSqlEx *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeSqlEx, sizeof(struct _ns2__executeSqlEx), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeSqlEx(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sqlId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sqlId", &a->sqlId, "xsd:string"))
				{	soap_flag_sqlId--;
					continue;
				}
			if (soap_flag_sqlParam && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sqlParam", &a->sqlParam, "xsd:string"))
				{	soap_flag_sqlParam--;
					continue;
				}
			if (soap_flag_pageSize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:pageSize", &a->pageSize, "xsd:int"))
				{	soap_flag_pageSize--;
					continue;
				}
			if (soap_flag_Nowpage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns2:Nowpage", &a->Nowpage, "xsd:int"))
				{	soap_flag_Nowpage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeSqlEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeSqlEx, 0, sizeof(struct _ns2__executeSqlEx), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pageSize > 0 || soap_flag_Nowpage > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeSqlEx(struct soap *soap, const struct _ns2__executeSqlEx *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeSqlEx);
	if (soap_out__ns2__executeSqlEx(soap, tag?tag:"ns2:executeSqlEx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeSqlEx * SOAP_FMAC4 soap_get__ns2__executeSqlEx(struct soap *soap, struct _ns2__executeSqlEx *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeSqlEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeUpdateResponse(struct soap *soap, struct _ns2__executeUpdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->executeUpdateReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeUpdateResponse(struct soap *soap, const struct _ns2__executeUpdateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->executeUpdateReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeUpdateResponse(struct soap *soap, const char *tag, int id, const struct _ns2__executeUpdateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeUpdateResponse), type))
		return soap->error;
	if (a->executeUpdateReturn)
		soap_element_result(soap, "ns2:executeUpdateReturn");
	if (soap_out_string(soap, "ns2:executeUpdateReturn", -1, &a->executeUpdateReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeUpdateResponse * SOAP_FMAC4 soap_in__ns2__executeUpdateResponse(struct soap *soap, const char *tag, struct _ns2__executeUpdateResponse *a, const char *type)
{
	size_t soap_flag_executeUpdateReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeUpdateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeUpdateResponse, sizeof(struct _ns2__executeUpdateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeUpdateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executeUpdateReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:executeUpdateReturn", &a->executeUpdateReturn, "xsd:string"))
				{	soap_flag_executeUpdateReturn--;
					continue;
				}
			soap_check_result(soap, "ns2:executeUpdateReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeUpdateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeUpdateResponse, 0, sizeof(struct _ns2__executeUpdateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeUpdateResponse(struct soap *soap, const struct _ns2__executeUpdateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeUpdateResponse);
	if (soap_out__ns2__executeUpdateResponse(soap, tag?tag:"ns2:executeUpdateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeUpdateResponse * SOAP_FMAC4 soap_get__ns2__executeUpdateResponse(struct soap *soap, struct _ns2__executeUpdateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeUpdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeUpdate(struct soap *soap, struct _ns2__executeUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sql);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeUpdate(struct soap *soap, const struct _ns2__executeUpdate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sql);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeUpdate(struct soap *soap, const char *tag, int id, const struct _ns2__executeUpdate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeUpdate), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:sql", -1, &a->sql, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeUpdate * SOAP_FMAC4 soap_in__ns2__executeUpdate(struct soap *soap, const char *tag, struct _ns2__executeUpdate *a, const char *type)
{
	size_t soap_flag_sql = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeUpdate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeUpdate, sizeof(struct _ns2__executeUpdate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeUpdate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sql && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sql", &a->sql, "xsd:string"))
				{	soap_flag_sql--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeUpdate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeUpdate, 0, sizeof(struct _ns2__executeUpdate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeUpdate(struct soap *soap, const struct _ns2__executeUpdate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeUpdate);
	if (soap_out__ns2__executeUpdate(soap, tag?tag:"ns2:executeUpdate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeUpdate * SOAP_FMAC4 soap_get__ns2__executeUpdate(struct soap *soap, struct _ns2__executeUpdate *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeSqlResponse(struct soap *soap, struct _ns2__executeSqlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->executeSqlReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeSqlResponse(struct soap *soap, const struct _ns2__executeSqlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->executeSqlReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeSqlResponse(struct soap *soap, const char *tag, int id, const struct _ns2__executeSqlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeSqlResponse), type))
		return soap->error;
	if (a->executeSqlReturn)
		soap_element_result(soap, "ns2:executeSqlReturn");
	if (soap_out_string(soap, "ns2:executeSqlReturn", -1, &a->executeSqlReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeSqlResponse * SOAP_FMAC4 soap_in__ns2__executeSqlResponse(struct soap *soap, const char *tag, struct _ns2__executeSqlResponse *a, const char *type)
{
	size_t soap_flag_executeSqlReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeSqlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeSqlResponse, sizeof(struct _ns2__executeSqlResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeSqlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_executeSqlReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:executeSqlReturn", &a->executeSqlReturn, "xsd:string"))
				{	soap_flag_executeSqlReturn--;
					continue;
				}
			soap_check_result(soap, "ns2:executeSqlReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeSqlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeSqlResponse, 0, sizeof(struct _ns2__executeSqlResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeSqlResponse(struct soap *soap, const struct _ns2__executeSqlResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeSqlResponse);
	if (soap_out__ns2__executeSqlResponse(soap, tag?tag:"ns2:executeSqlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeSqlResponse * SOAP_FMAC4 soap_get__ns2__executeSqlResponse(struct soap *soap, struct _ns2__executeSqlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeSqlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns2__executeSql(struct soap *soap, struct _ns2__executeSql *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->sqlId);
	soap_default_string(soap, &a->sqlParam);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns2__executeSql(struct soap *soap, const struct _ns2__executeSql *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->sqlId);
	soap_serialize_string(soap, &a->sqlParam);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns2__executeSql(struct soap *soap, const char *tag, int id, const struct _ns2__executeSql *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns2__executeSql), type))
		return soap->error;
	if (soap_out_string(soap, "ns2:sqlId", -1, &a->sqlId, ""))
		return soap->error;
	if (soap_out_string(soap, "ns2:sqlParam", -1, &a->sqlParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns2__executeSql * SOAP_FMAC4 soap_in__ns2__executeSql(struct soap *soap, const char *tag, struct _ns2__executeSql *a, const char *type)
{
	size_t soap_flag_sqlId = 1;
	size_t soap_flag_sqlParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns2__executeSql *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns2__executeSql, sizeof(struct _ns2__executeSql), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns2__executeSql(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sqlId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sqlId", &a->sqlId, "xsd:string"))
				{	soap_flag_sqlId--;
					continue;
				}
			if (soap_flag_sqlParam && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns2:sqlParam", &a->sqlParam, "xsd:string"))
				{	soap_flag_sqlParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeSql *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns2__executeSql, 0, sizeof(struct _ns2__executeSql), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns2__executeSql(struct soap *soap, const struct _ns2__executeSql *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns2__executeSql);
	if (soap_out__ns2__executeSql(soap, tag?tag:"ns2:executeSql", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeSql * SOAP_FMAC4 soap_get__ns2__executeSql(struct soap *soap, struct _ns2__executeSql *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns2__executeSql(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, struct _ns1__GetVpdnOnlineIPByImsiResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetVpdnOnlineIPByImsiReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, const struct _ns1__GetVpdnOnlineIPByImsiResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__VpdnOnlineIPResponse(soap, &a->GetVpdnOnlineIPByImsiReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetVpdnOnlineIPByImsiResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsiResponse), type))
		return soap->error;
	if (a->GetVpdnOnlineIPByImsiReturn)
		soap_element_result(soap, "ns1:GetVpdnOnlineIPByImsiReturn");
	if (soap_out_PointerTons1__VpdnOnlineIPResponse(soap, "ns1:GetVpdnOnlineIPByImsiReturn", -1, &a->GetVpdnOnlineIPByImsiReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetVpdnOnlineIPByImsiResponse * SOAP_FMAC4 soap_in__ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, const char *tag, struct _ns1__GetVpdnOnlineIPByImsiResponse *a, const char *type)
{
	size_t soap_flag_GetVpdnOnlineIPByImsiReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetVpdnOnlineIPByImsiResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsiResponse, sizeof(struct _ns1__GetVpdnOnlineIPByImsiResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetVpdnOnlineIPByImsiResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetVpdnOnlineIPByImsiReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VpdnOnlineIPResponse(soap, "ns1:GetVpdnOnlineIPByImsiReturn", &a->GetVpdnOnlineIPByImsiReturn, "ns1:VpdnOnlineIPResponse"))
				{	soap_flag_GetVpdnOnlineIPByImsiReturn--;
					continue;
				}
			soap_check_result(soap, "ns1:GetVpdnOnlineIPByImsiReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVpdnOnlineIPByImsiResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsiResponse, 0, sizeof(struct _ns1__GetVpdnOnlineIPByImsiResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetVpdnOnlineIPByImsiReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, const struct _ns1__GetVpdnOnlineIPByImsiResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsiResponse);
	if (soap_out__ns1__GetVpdnOnlineIPByImsiResponse(soap, tag?tag:"ns1:GetVpdnOnlineIPByImsiResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVpdnOnlineIPByImsiResponse * SOAP_FMAC4 soap_get__ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, struct _ns1__GetVpdnOnlineIPByImsiResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVpdnOnlineIPByImsiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetVpdnOnlineIPByImsi(struct soap *soap, struct _ns1__GetVpdnOnlineIPByImsi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->request = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetVpdnOnlineIPByImsi(struct soap *soap, const struct _ns1__GetVpdnOnlineIPByImsi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__VpdnOnlineIPRequest(soap, &a->request);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVpdnOnlineIPByImsi(struct soap *soap, const char *tag, int id, const struct _ns1__GetVpdnOnlineIPByImsi *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsi), type))
		return soap->error;
	if (soap_out_PointerTons1__VpdnOnlineIPRequest(soap, "ns1:request", -1, &a->request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetVpdnOnlineIPByImsi * SOAP_FMAC4 soap_in__ns1__GetVpdnOnlineIPByImsi(struct soap *soap, const char *tag, struct _ns1__GetVpdnOnlineIPByImsi *a, const char *type)
{
	size_t soap_flag_request = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetVpdnOnlineIPByImsi *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsi, sizeof(struct _ns1__GetVpdnOnlineIPByImsi), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetVpdnOnlineIPByImsi(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VpdnOnlineIPRequest(soap, "ns1:request", &a->request, "ns1:VpdnOnlineIPRequest"))
				{	soap_flag_request--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVpdnOnlineIPByImsi *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsi, 0, sizeof(struct _ns1__GetVpdnOnlineIPByImsi), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_request > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetVpdnOnlineIPByImsi(struct soap *soap, const struct _ns1__GetVpdnOnlineIPByImsi *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsi);
	if (soap_out__ns1__GetVpdnOnlineIPByImsi(soap, tag?tag:"ns1:GetVpdnOnlineIPByImsi", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVpdnOnlineIPByImsi * SOAP_FMAC4 soap_get__ns1__GetVpdnOnlineIPByImsi(struct soap *soap, struct _ns1__GetVpdnOnlineIPByImsi *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVpdnOnlineIPByImsi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetVpdnIPByImsiResponse(struct soap *soap, struct _ns1__GetVpdnIPByImsiResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GetVpdnIPByImsiReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetVpdnIPByImsiResponse(struct soap *soap, const struct _ns1__GetVpdnIPByImsiResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__VpdnIPResponse(soap, &a->GetVpdnIPByImsiReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVpdnIPByImsiResponse(struct soap *soap, const char *tag, int id, const struct _ns1__GetVpdnIPByImsiResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVpdnIPByImsiResponse), type))
		return soap->error;
	if (a->GetVpdnIPByImsiReturn)
		soap_element_result(soap, "ns1:GetVpdnIPByImsiReturn");
	if (soap_out_PointerTons1__VpdnIPResponse(soap, "ns1:GetVpdnIPByImsiReturn", -1, &a->GetVpdnIPByImsiReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetVpdnIPByImsiResponse * SOAP_FMAC4 soap_in__ns1__GetVpdnIPByImsiResponse(struct soap *soap, const char *tag, struct _ns1__GetVpdnIPByImsiResponse *a, const char *type)
{
	size_t soap_flag_GetVpdnIPByImsiReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetVpdnIPByImsiResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVpdnIPByImsiResponse, sizeof(struct _ns1__GetVpdnIPByImsiResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetVpdnIPByImsiResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetVpdnIPByImsiReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VpdnIPResponse(soap, "ns1:GetVpdnIPByImsiReturn", &a->GetVpdnIPByImsiReturn, "ns1:VpdnIPResponse"))
				{	soap_flag_GetVpdnIPByImsiReturn--;
					continue;
				}
			soap_check_result(soap, "ns1:GetVpdnIPByImsiReturn");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVpdnIPByImsiResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVpdnIPByImsiResponse, 0, sizeof(struct _ns1__GetVpdnIPByImsiResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetVpdnIPByImsiReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetVpdnIPByImsiResponse(struct soap *soap, const struct _ns1__GetVpdnIPByImsiResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetVpdnIPByImsiResponse);
	if (soap_out__ns1__GetVpdnIPByImsiResponse(soap, tag?tag:"ns1:GetVpdnIPByImsiResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVpdnIPByImsiResponse * SOAP_FMAC4 soap_get__ns1__GetVpdnIPByImsiResponse(struct soap *soap, struct _ns1__GetVpdnIPByImsiResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVpdnIPByImsiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns1__GetVpdnIPByImsi(struct soap *soap, struct _ns1__GetVpdnIPByImsi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->request = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__GetVpdnIPByImsi(struct soap *soap, const struct _ns1__GetVpdnIPByImsi *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__VpdnIPRequest(soap, &a->request);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVpdnIPByImsi(struct soap *soap, const char *tag, int id, const struct _ns1__GetVpdnIPByImsi *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVpdnIPByImsi), type))
		return soap->error;
	if (soap_out_PointerTons1__VpdnIPRequest(soap, "ns1:request", -1, &a->request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns1__GetVpdnIPByImsi * SOAP_FMAC4 soap_in__ns1__GetVpdnIPByImsi(struct soap *soap, const char *tag, struct _ns1__GetVpdnIPByImsi *a, const char *type)
{
	size_t soap_flag_request = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns1__GetVpdnIPByImsi *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVpdnIPByImsi, sizeof(struct _ns1__GetVpdnIPByImsi), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns1__GetVpdnIPByImsi(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__VpdnIPRequest(soap, "ns1:request", &a->request, "ns1:VpdnIPRequest"))
				{	soap_flag_request--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVpdnIPByImsi *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVpdnIPByImsi, 0, sizeof(struct _ns1__GetVpdnIPByImsi), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_request > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns1__GetVpdnIPByImsi(struct soap *soap, const struct _ns1__GetVpdnIPByImsi *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__ns1__GetVpdnIPByImsi);
	if (soap_out__ns1__GetVpdnIPByImsi(soap, tag?tag:"ns1:GetVpdnIPByImsi", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVpdnIPByImsi * SOAP_FMAC4 soap_get__ns1__GetVpdnIPByImsi(struct soap *soap, struct _ns1__GetVpdnIPByImsi *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVpdnIPByImsi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VpdnOnlineIPResponse(struct soap *soap, struct ns1__VpdnOnlineIPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ip);
	soap_default_int(soap, &a->ret);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__VpdnOnlineIPResponse(struct soap *soap, const struct ns1__VpdnOnlineIPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ip);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VpdnOnlineIPResponse(struct soap *soap, const char *tag, int id, const struct ns1__VpdnOnlineIPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VpdnOnlineIPResponse), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:ip", -1, &a->ip, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ret", -1, &a->ret, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__VpdnOnlineIPResponse * SOAP_FMAC4 soap_in_ns1__VpdnOnlineIPResponse(struct soap *soap, const char *tag, struct ns1__VpdnOnlineIPResponse *a, const char *type)
{
	size_t soap_flag_ip = 1;
	size_t soap_flag_ret = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__VpdnOnlineIPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VpdnOnlineIPResponse, sizeof(struct ns1__VpdnOnlineIPResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__VpdnOnlineIPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ip && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ip", &a->ip, "xsd:string"))
				{	soap_flag_ip--;
					continue;
				}
			if (soap_flag_ret && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ret", &a->ret, "xsd:int"))
				{	soap_flag_ret--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__VpdnOnlineIPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VpdnOnlineIPResponse, 0, sizeof(struct ns1__VpdnOnlineIPResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ret > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VpdnOnlineIPResponse(struct soap *soap, const struct ns1__VpdnOnlineIPResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VpdnOnlineIPResponse);
	if (soap_out_ns1__VpdnOnlineIPResponse(soap, tag?tag:"ns1:VpdnOnlineIPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VpdnOnlineIPResponse * SOAP_FMAC4 soap_get_ns1__VpdnOnlineIPResponse(struct soap *soap, struct ns1__VpdnOnlineIPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VpdnOnlineIPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VpdnOnlineIPRequest(struct soap *soap, struct ns1__VpdnOnlineIPRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->imsi);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__VpdnOnlineIPRequest(struct soap *soap, const struct ns1__VpdnOnlineIPRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->imsi);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VpdnOnlineIPRequest(struct soap *soap, const char *tag, int id, const struct ns1__VpdnOnlineIPRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VpdnOnlineIPRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:imsi", -1, &a->imsi, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__VpdnOnlineIPRequest * SOAP_FMAC4 soap_in_ns1__VpdnOnlineIPRequest(struct soap *soap, const char *tag, struct ns1__VpdnOnlineIPRequest *a, const char *type)
{
	size_t soap_flag_imsi = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__VpdnOnlineIPRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VpdnOnlineIPRequest, sizeof(struct ns1__VpdnOnlineIPRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__VpdnOnlineIPRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_imsi && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:imsi", &a->imsi, "xsd:string"))
				{	soap_flag_imsi--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__VpdnOnlineIPRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VpdnOnlineIPRequest, 0, sizeof(struct ns1__VpdnOnlineIPRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VpdnOnlineIPRequest(struct soap *soap, const struct ns1__VpdnOnlineIPRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VpdnOnlineIPRequest);
	if (soap_out_ns1__VpdnOnlineIPRequest(soap, tag?tag:"ns1:VpdnOnlineIPRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VpdnOnlineIPRequest * SOAP_FMAC4 soap_get_ns1__VpdnOnlineIPRequest(struct soap *soap, struct ns1__VpdnOnlineIPRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VpdnOnlineIPRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VpdnIPResponse(struct soap *soap, struct ns1__VpdnIPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->ip);
	soap_default_int(soap, &a->ret);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__VpdnIPResponse(struct soap *soap, const struct ns1__VpdnIPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->ip);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VpdnIPResponse(struct soap *soap, const char *tag, int id, const struct ns1__VpdnIPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VpdnIPResponse), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:ip", -1, &a->ip, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:ret", -1, &a->ret, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__VpdnIPResponse * SOAP_FMAC4 soap_in_ns1__VpdnIPResponse(struct soap *soap, const char *tag, struct ns1__VpdnIPResponse *a, const char *type)
{
	size_t soap_flag_ip = 1;
	size_t soap_flag_ret = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__VpdnIPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VpdnIPResponse, sizeof(struct ns1__VpdnIPResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__VpdnIPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ip && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ip", &a->ip, "xsd:string"))
				{	soap_flag_ip--;
					continue;
				}
			if (soap_flag_ret && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:ret", &a->ret, "xsd:int"))
				{	soap_flag_ret--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__VpdnIPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VpdnIPResponse, 0, sizeof(struct ns1__VpdnIPResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ret > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VpdnIPResponse(struct soap *soap, const struct ns1__VpdnIPResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VpdnIPResponse);
	if (soap_out_ns1__VpdnIPResponse(soap, tag?tag:"ns1:VpdnIPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VpdnIPResponse * SOAP_FMAC4 soap_get_ns1__VpdnIPResponse(struct soap *soap, struct ns1__VpdnIPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VpdnIPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__VpdnIPRequest(struct soap *soap, struct ns1__VpdnIPRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->imsi);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__VpdnIPRequest(struct soap *soap, const struct ns1__VpdnIPRequest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->imsi);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__VpdnIPRequest(struct soap *soap, const char *tag, int id, const struct ns1__VpdnIPRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__VpdnIPRequest), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:imsi", -1, &a->imsi, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__VpdnIPRequest * SOAP_FMAC4 soap_in_ns1__VpdnIPRequest(struct soap *soap, const char *tag, struct ns1__VpdnIPRequest *a, const char *type)
{
	size_t soap_flag_imsi = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__VpdnIPRequest *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__VpdnIPRequest, sizeof(struct ns1__VpdnIPRequest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__VpdnIPRequest(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_imsi && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:imsi", &a->imsi, "xsd:string"))
				{	soap_flag_imsi--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__VpdnIPRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__VpdnIPRequest, 0, sizeof(struct ns1__VpdnIPRequest), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__VpdnIPRequest(struct soap *soap, const struct ns1__VpdnIPRequest *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__VpdnIPRequest);
	if (soap_out_ns1__VpdnIPRequest(soap, tag?tag:"ns1:VpdnIPRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VpdnIPRequest * SOAP_FMAC4 soap_get_ns1__VpdnIPRequest(struct soap *soap, struct ns1__VpdnIPRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__VpdnIPRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__callResponse(struct soap *soap, struct _ns2__callResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__callResponse))
		soap_serialize__ns2__callResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__callResponse(struct soap *soap, const char *tag, int id, struct _ns2__callResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__callResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__callResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__callResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__callResponse(struct soap *soap, const char *tag, struct _ns2__callResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__callResponse **)soap_malloc(soap, sizeof(struct _ns2__callResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__callResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__callResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__callResponse, sizeof(struct _ns2__callResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__callResponse(struct soap *soap, struct _ns2__callResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__callResponse);
	if (soap_out_PointerTo_ns2__callResponse(soap, tag?tag:"ns2:callResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__callResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__callResponse(struct soap *soap, struct _ns2__callResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__callResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__call(struct soap *soap, struct _ns2__call *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__call))
		soap_serialize__ns2__call(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__call(struct soap *soap, const char *tag, int id, struct _ns2__call *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__call);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__call(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__call ** SOAP_FMAC4 soap_in_PointerTo_ns2__call(struct soap *soap, const char *tag, struct _ns2__call **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__call **)soap_malloc(soap, sizeof(struct _ns2__call *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__call(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__call **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__call, sizeof(struct _ns2__call), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__call(struct soap *soap, struct _ns2__call *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__call);
	if (soap_out_PointerTo_ns2__call(soap, tag?tag:"ns2:call", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__call ** SOAP_FMAC4 soap_get_PointerTo_ns2__call(struct soap *soap, struct _ns2__call **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__call(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeXMLResponse(struct soap *soap, struct _ns2__executeXMLResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeXMLResponse))
		soap_serialize__ns2__executeXMLResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeXMLResponse(struct soap *soap, const char *tag, int id, struct _ns2__executeXMLResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeXMLResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeXMLResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeXMLResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeXMLResponse(struct soap *soap, const char *tag, struct _ns2__executeXMLResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeXMLResponse **)soap_malloc(soap, sizeof(struct _ns2__executeXMLResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeXMLResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeXMLResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeXMLResponse, sizeof(struct _ns2__executeXMLResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeXMLResponse(struct soap *soap, struct _ns2__executeXMLResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeXMLResponse);
	if (soap_out_PointerTo_ns2__executeXMLResponse(soap, tag?tag:"ns2:executeXMLResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeXMLResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeXMLResponse(struct soap *soap, struct _ns2__executeXMLResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeXMLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeXML(struct soap *soap, struct _ns2__executeXML *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeXML))
		soap_serialize__ns2__executeXML(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeXML(struct soap *soap, const char *tag, int id, struct _ns2__executeXML *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeXML);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeXML(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeXML ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeXML(struct soap *soap, const char *tag, struct _ns2__executeXML **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeXML **)soap_malloc(soap, sizeof(struct _ns2__executeXML *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeXML(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeXML **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeXML, sizeof(struct _ns2__executeXML), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeXML(struct soap *soap, struct _ns2__executeXML *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeXML);
	if (soap_out_PointerTo_ns2__executeXML(soap, tag?tag:"ns2:executeXML", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeXML ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeXML(struct soap *soap, struct _ns2__executeXML **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeXML(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeQueryOraResponse(struct soap *soap, struct _ns2__executeQueryOraResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeQueryOraResponse))
		soap_serialize__ns2__executeQueryOraResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeQueryOraResponse(struct soap *soap, const char *tag, int id, struct _ns2__executeQueryOraResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeQueryOraResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeQueryOraResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeQueryOraResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeQueryOraResponse(struct soap *soap, const char *tag, struct _ns2__executeQueryOraResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeQueryOraResponse **)soap_malloc(soap, sizeof(struct _ns2__executeQueryOraResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeQueryOraResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQueryOraResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeQueryOraResponse, sizeof(struct _ns2__executeQueryOraResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeQueryOraResponse(struct soap *soap, struct _ns2__executeQueryOraResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeQueryOraResponse);
	if (soap_out_PointerTo_ns2__executeQueryOraResponse(soap, tag?tag:"ns2:executeQueryOraResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQueryOraResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeQueryOraResponse(struct soap *soap, struct _ns2__executeQueryOraResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeQueryOraResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeQueryOra(struct soap *soap, struct _ns2__executeQueryOra *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeQueryOra))
		soap_serialize__ns2__executeQueryOra(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeQueryOra(struct soap *soap, const char *tag, int id, struct _ns2__executeQueryOra *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeQueryOra);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeQueryOra(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeQueryOra ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeQueryOra(struct soap *soap, const char *tag, struct _ns2__executeQueryOra **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeQueryOra **)soap_malloc(soap, sizeof(struct _ns2__executeQueryOra *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeQueryOra(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQueryOra **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeQueryOra, sizeof(struct _ns2__executeQueryOra), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeQueryOra(struct soap *soap, struct _ns2__executeQueryOra *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeQueryOra);
	if (soap_out_PointerTo_ns2__executeQueryOra(soap, tag?tag:"ns2:executeQueryOra", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQueryOra ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeQueryOra(struct soap *soap, struct _ns2__executeQueryOra **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeQueryOra(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeProcedureResponse(struct soap *soap, struct _ns2__executeProcedureResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeProcedureResponse))
		soap_serialize__ns2__executeProcedureResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeProcedureResponse(struct soap *soap, const char *tag, int id, struct _ns2__executeProcedureResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeProcedureResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeProcedureResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeProcedureResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeProcedureResponse(struct soap *soap, const char *tag, struct _ns2__executeProcedureResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeProcedureResponse **)soap_malloc(soap, sizeof(struct _ns2__executeProcedureResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeProcedureResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeProcedureResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeProcedureResponse, sizeof(struct _ns2__executeProcedureResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeProcedureResponse(struct soap *soap, struct _ns2__executeProcedureResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeProcedureResponse);
	if (soap_out_PointerTo_ns2__executeProcedureResponse(soap, tag?tag:"ns2:executeProcedureResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeProcedureResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeProcedureResponse(struct soap *soap, struct _ns2__executeProcedureResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeProcedureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeProcedure(struct soap *soap, struct _ns2__executeProcedure *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeProcedure))
		soap_serialize__ns2__executeProcedure(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeProcedure(struct soap *soap, const char *tag, int id, struct _ns2__executeProcedure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeProcedure);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeProcedure(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeProcedure ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeProcedure(struct soap *soap, const char *tag, struct _ns2__executeProcedure **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeProcedure **)soap_malloc(soap, sizeof(struct _ns2__executeProcedure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeProcedure(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeProcedure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeProcedure, sizeof(struct _ns2__executeProcedure), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeProcedure(struct soap *soap, struct _ns2__executeProcedure *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeProcedure);
	if (soap_out_PointerTo_ns2__executeProcedure(soap, tag?tag:"ns2:executeProcedure", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeProcedure ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeProcedure(struct soap *soap, struct _ns2__executeProcedure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeProcedure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeQueryExResponse(struct soap *soap, struct _ns2__executeQueryExResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeQueryExResponse))
		soap_serialize__ns2__executeQueryExResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeQueryExResponse(struct soap *soap, const char *tag, int id, struct _ns2__executeQueryExResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeQueryExResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeQueryExResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeQueryExResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeQueryExResponse(struct soap *soap, const char *tag, struct _ns2__executeQueryExResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeQueryExResponse **)soap_malloc(soap, sizeof(struct _ns2__executeQueryExResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeQueryExResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQueryExResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeQueryExResponse, sizeof(struct _ns2__executeQueryExResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeQueryExResponse(struct soap *soap, struct _ns2__executeQueryExResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeQueryExResponse);
	if (soap_out_PointerTo_ns2__executeQueryExResponse(soap, tag?tag:"ns2:executeQueryExResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQueryExResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeQueryExResponse(struct soap *soap, struct _ns2__executeQueryExResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeQueryExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeQueryEx(struct soap *soap, struct _ns2__executeQueryEx *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeQueryEx))
		soap_serialize__ns2__executeQueryEx(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeQueryEx(struct soap *soap, const char *tag, int id, struct _ns2__executeQueryEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeQueryEx);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeQueryEx(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeQueryEx ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeQueryEx(struct soap *soap, const char *tag, struct _ns2__executeQueryEx **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeQueryEx **)soap_malloc(soap, sizeof(struct _ns2__executeQueryEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeQueryEx(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQueryEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeQueryEx, sizeof(struct _ns2__executeQueryEx), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeQueryEx(struct soap *soap, struct _ns2__executeQueryEx *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeQueryEx);
	if (soap_out_PointerTo_ns2__executeQueryEx(soap, tag?tag:"ns2:executeQueryEx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQueryEx ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeQueryEx(struct soap *soap, struct _ns2__executeQueryEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeQueryEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeQueryResponse(struct soap *soap, struct _ns2__executeQueryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeQueryResponse))
		soap_serialize__ns2__executeQueryResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeQueryResponse(struct soap *soap, const char *tag, int id, struct _ns2__executeQueryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeQueryResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeQueryResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeQueryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeQueryResponse(struct soap *soap, const char *tag, struct _ns2__executeQueryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeQueryResponse **)soap_malloc(soap, sizeof(struct _ns2__executeQueryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeQueryResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQueryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeQueryResponse, sizeof(struct _ns2__executeQueryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeQueryResponse(struct soap *soap, struct _ns2__executeQueryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeQueryResponse);
	if (soap_out_PointerTo_ns2__executeQueryResponse(soap, tag?tag:"ns2:executeQueryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQueryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeQueryResponse(struct soap *soap, struct _ns2__executeQueryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeQueryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeQuery(struct soap *soap, struct _ns2__executeQuery *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeQuery))
		soap_serialize__ns2__executeQuery(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeQuery(struct soap *soap, const char *tag, int id, struct _ns2__executeQuery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeQuery);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeQuery(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeQuery ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeQuery(struct soap *soap, const char *tag, struct _ns2__executeQuery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeQuery **)soap_malloc(soap, sizeof(struct _ns2__executeQuery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeQuery(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeQuery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeQuery, sizeof(struct _ns2__executeQuery), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeQuery(struct soap *soap, struct _ns2__executeQuery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeQuery);
	if (soap_out_PointerTo_ns2__executeQuery(soap, tag?tag:"ns2:executeQuery", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeQuery ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeQuery(struct soap *soap, struct _ns2__executeQuery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeQuery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeProcedureExResponse(struct soap *soap, struct _ns2__executeProcedureExResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeProcedureExResponse))
		soap_serialize__ns2__executeProcedureExResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeProcedureExResponse(struct soap *soap, const char *tag, int id, struct _ns2__executeProcedureExResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeProcedureExResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeProcedureExResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeProcedureExResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeProcedureExResponse(struct soap *soap, const char *tag, struct _ns2__executeProcedureExResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeProcedureExResponse **)soap_malloc(soap, sizeof(struct _ns2__executeProcedureExResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeProcedureExResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeProcedureExResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeProcedureExResponse, sizeof(struct _ns2__executeProcedureExResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeProcedureExResponse(struct soap *soap, struct _ns2__executeProcedureExResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeProcedureExResponse);
	if (soap_out_PointerTo_ns2__executeProcedureExResponse(soap, tag?tag:"ns2:executeProcedureExResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeProcedureExResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeProcedureExResponse(struct soap *soap, struct _ns2__executeProcedureExResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeProcedureExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeProcedureEx(struct soap *soap, struct _ns2__executeProcedureEx *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeProcedureEx))
		soap_serialize__ns2__executeProcedureEx(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeProcedureEx(struct soap *soap, const char *tag, int id, struct _ns2__executeProcedureEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeProcedureEx);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeProcedureEx(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeProcedureEx ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeProcedureEx(struct soap *soap, const char *tag, struct _ns2__executeProcedureEx **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeProcedureEx **)soap_malloc(soap, sizeof(struct _ns2__executeProcedureEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeProcedureEx(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeProcedureEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeProcedureEx, sizeof(struct _ns2__executeProcedureEx), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeProcedureEx(struct soap *soap, struct _ns2__executeProcedureEx *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeProcedureEx);
	if (soap_out_PointerTo_ns2__executeProcedureEx(soap, tag?tag:"ns2:executeProcedureEx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeProcedureEx ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeProcedureEx(struct soap *soap, struct _ns2__executeProcedureEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeProcedureEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeSqlExResponse(struct soap *soap, struct _ns2__executeSqlExResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeSqlExResponse))
		soap_serialize__ns2__executeSqlExResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeSqlExResponse(struct soap *soap, const char *tag, int id, struct _ns2__executeSqlExResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeSqlExResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeSqlExResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeSqlExResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeSqlExResponse(struct soap *soap, const char *tag, struct _ns2__executeSqlExResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeSqlExResponse **)soap_malloc(soap, sizeof(struct _ns2__executeSqlExResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeSqlExResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeSqlExResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeSqlExResponse, sizeof(struct _ns2__executeSqlExResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeSqlExResponse(struct soap *soap, struct _ns2__executeSqlExResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeSqlExResponse);
	if (soap_out_PointerTo_ns2__executeSqlExResponse(soap, tag?tag:"ns2:executeSqlExResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeSqlExResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeSqlExResponse(struct soap *soap, struct _ns2__executeSqlExResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeSqlExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeSqlEx(struct soap *soap, struct _ns2__executeSqlEx *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeSqlEx))
		soap_serialize__ns2__executeSqlEx(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeSqlEx(struct soap *soap, const char *tag, int id, struct _ns2__executeSqlEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeSqlEx);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeSqlEx(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeSqlEx ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeSqlEx(struct soap *soap, const char *tag, struct _ns2__executeSqlEx **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeSqlEx **)soap_malloc(soap, sizeof(struct _ns2__executeSqlEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeSqlEx(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeSqlEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeSqlEx, sizeof(struct _ns2__executeSqlEx), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeSqlEx(struct soap *soap, struct _ns2__executeSqlEx *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeSqlEx);
	if (soap_out_PointerTo_ns2__executeSqlEx(soap, tag?tag:"ns2:executeSqlEx", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeSqlEx ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeSqlEx(struct soap *soap, struct _ns2__executeSqlEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeSqlEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeUpdateResponse(struct soap *soap, struct _ns2__executeUpdateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeUpdateResponse))
		soap_serialize__ns2__executeUpdateResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeUpdateResponse(struct soap *soap, const char *tag, int id, struct _ns2__executeUpdateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeUpdateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeUpdateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeUpdateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeUpdateResponse(struct soap *soap, const char *tag, struct _ns2__executeUpdateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeUpdateResponse **)soap_malloc(soap, sizeof(struct _ns2__executeUpdateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeUpdateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeUpdateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeUpdateResponse, sizeof(struct _ns2__executeUpdateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeUpdateResponse(struct soap *soap, struct _ns2__executeUpdateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeUpdateResponse);
	if (soap_out_PointerTo_ns2__executeUpdateResponse(soap, tag?tag:"ns2:executeUpdateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeUpdateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeUpdateResponse(struct soap *soap, struct _ns2__executeUpdateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeUpdateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeUpdate(struct soap *soap, struct _ns2__executeUpdate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeUpdate))
		soap_serialize__ns2__executeUpdate(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeUpdate(struct soap *soap, const char *tag, int id, struct _ns2__executeUpdate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeUpdate);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeUpdate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeUpdate ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeUpdate(struct soap *soap, const char *tag, struct _ns2__executeUpdate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeUpdate **)soap_malloc(soap, sizeof(struct _ns2__executeUpdate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeUpdate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeUpdate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeUpdate, sizeof(struct _ns2__executeUpdate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeUpdate(struct soap *soap, struct _ns2__executeUpdate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeUpdate);
	if (soap_out_PointerTo_ns2__executeUpdate(soap, tag?tag:"ns2:executeUpdate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeUpdate ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeUpdate(struct soap *soap, struct _ns2__executeUpdate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeUpdate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeSqlResponse(struct soap *soap, struct _ns2__executeSqlResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeSqlResponse))
		soap_serialize__ns2__executeSqlResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeSqlResponse(struct soap *soap, const char *tag, int id, struct _ns2__executeSqlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeSqlResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeSqlResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeSqlResponse ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeSqlResponse(struct soap *soap, const char *tag, struct _ns2__executeSqlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeSqlResponse **)soap_malloc(soap, sizeof(struct _ns2__executeSqlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeSqlResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeSqlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeSqlResponse, sizeof(struct _ns2__executeSqlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeSqlResponse(struct soap *soap, struct _ns2__executeSqlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeSqlResponse);
	if (soap_out_PointerTo_ns2__executeSqlResponse(soap, tag?tag:"ns2:executeSqlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeSqlResponse ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeSqlResponse(struct soap *soap, struct _ns2__executeSqlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeSqlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns2__executeSql(struct soap *soap, struct _ns2__executeSql *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns2__executeSql))
		soap_serialize__ns2__executeSql(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns2__executeSql(struct soap *soap, const char *tag, int id, struct _ns2__executeSql *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns2__executeSql);
	if (id < 0)
		return soap->error;
	return soap_out__ns2__executeSql(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns2__executeSql ** SOAP_FMAC4 soap_in_PointerTo_ns2__executeSql(struct soap *soap, const char *tag, struct _ns2__executeSql **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns2__executeSql **)soap_malloc(soap, sizeof(struct _ns2__executeSql *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns2__executeSql(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns2__executeSql **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns2__executeSql, sizeof(struct _ns2__executeSql), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns2__executeSql(struct soap *soap, struct _ns2__executeSql *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns2__executeSql);
	if (soap_out_PointerTo_ns2__executeSql(soap, tag?tag:"ns2:executeSql", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns2__executeSql ** SOAP_FMAC4 soap_get_PointerTo_ns2__executeSql(struct soap *soap, struct _ns2__executeSql **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns2__executeSql(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, struct _ns1__GetVpdnOnlineIPByImsiResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsiResponse))
		soap_serialize__ns1__GetVpdnOnlineIPByImsiResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetVpdnOnlineIPByImsiResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsiResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetVpdnOnlineIPByImsiResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetVpdnOnlineIPByImsiResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, const char *tag, struct _ns1__GetVpdnOnlineIPByImsiResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetVpdnOnlineIPByImsiResponse **)soap_malloc(soap, sizeof(struct _ns1__GetVpdnOnlineIPByImsiResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetVpdnOnlineIPByImsiResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVpdnOnlineIPByImsiResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsiResponse, sizeof(struct _ns1__GetVpdnOnlineIPByImsiResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, struct _ns1__GetVpdnOnlineIPByImsiResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse);
	if (soap_out_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse(soap, tag?tag:"ns1:GetVpdnOnlineIPByImsiResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVpdnOnlineIPByImsiResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse(struct soap *soap, struct _ns1__GetVpdnOnlineIPByImsiResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVpdnOnlineIPByImsiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVpdnOnlineIPByImsi(struct soap *soap, struct _ns1__GetVpdnOnlineIPByImsi *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsi))
		soap_serialize__ns1__GetVpdnOnlineIPByImsi(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVpdnOnlineIPByImsi(struct soap *soap, const char *tag, int id, struct _ns1__GetVpdnOnlineIPByImsi *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsi);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetVpdnOnlineIPByImsi(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetVpdnOnlineIPByImsi ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVpdnOnlineIPByImsi(struct soap *soap, const char *tag, struct _ns1__GetVpdnOnlineIPByImsi **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetVpdnOnlineIPByImsi **)soap_malloc(soap, sizeof(struct _ns1__GetVpdnOnlineIPByImsi *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetVpdnOnlineIPByImsi(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVpdnOnlineIPByImsi **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVpdnOnlineIPByImsi, sizeof(struct _ns1__GetVpdnOnlineIPByImsi), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVpdnOnlineIPByImsi(struct soap *soap, struct _ns1__GetVpdnOnlineIPByImsi *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetVpdnOnlineIPByImsi);
	if (soap_out_PointerTo_ns1__GetVpdnOnlineIPByImsi(soap, tag?tag:"ns1:GetVpdnOnlineIPByImsi", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVpdnOnlineIPByImsi ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVpdnOnlineIPByImsi(struct soap *soap, struct _ns1__GetVpdnOnlineIPByImsi **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVpdnOnlineIPByImsi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVpdnIPByImsiResponse(struct soap *soap, struct _ns1__GetVpdnIPByImsiResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVpdnIPByImsiResponse))
		soap_serialize__ns1__GetVpdnIPByImsiResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVpdnIPByImsiResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetVpdnIPByImsiResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVpdnIPByImsiResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetVpdnIPByImsiResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetVpdnIPByImsiResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVpdnIPByImsiResponse(struct soap *soap, const char *tag, struct _ns1__GetVpdnIPByImsiResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetVpdnIPByImsiResponse **)soap_malloc(soap, sizeof(struct _ns1__GetVpdnIPByImsiResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetVpdnIPByImsiResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVpdnIPByImsiResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVpdnIPByImsiResponse, sizeof(struct _ns1__GetVpdnIPByImsiResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVpdnIPByImsiResponse(struct soap *soap, struct _ns1__GetVpdnIPByImsiResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetVpdnIPByImsiResponse);
	if (soap_out_PointerTo_ns1__GetVpdnIPByImsiResponse(soap, tag?tag:"ns1:GetVpdnIPByImsiResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVpdnIPByImsiResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVpdnIPByImsiResponse(struct soap *soap, struct _ns1__GetVpdnIPByImsiResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVpdnIPByImsiResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVpdnIPByImsi(struct soap *soap, struct _ns1__GetVpdnIPByImsi *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVpdnIPByImsi))
		soap_serialize__ns1__GetVpdnIPByImsi(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVpdnIPByImsi(struct soap *soap, const char *tag, int id, struct _ns1__GetVpdnIPByImsi *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVpdnIPByImsi);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetVpdnIPByImsi(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetVpdnIPByImsi ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVpdnIPByImsi(struct soap *soap, const char *tag, struct _ns1__GetVpdnIPByImsi **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetVpdnIPByImsi **)soap_malloc(soap, sizeof(struct _ns1__GetVpdnIPByImsi *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetVpdnIPByImsi(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetVpdnIPByImsi **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVpdnIPByImsi, sizeof(struct _ns1__GetVpdnIPByImsi), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVpdnIPByImsi(struct soap *soap, struct _ns1__GetVpdnIPByImsi *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetVpdnIPByImsi);
	if (soap_out_PointerTo_ns1__GetVpdnIPByImsi(soap, tag?tag:"ns1:GetVpdnIPByImsi", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetVpdnIPByImsi ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVpdnIPByImsi(struct soap *soap, struct _ns1__GetVpdnIPByImsi **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVpdnIPByImsi(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VpdnOnlineIPResponse(struct soap *soap, struct ns1__VpdnOnlineIPResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VpdnOnlineIPResponse))
		soap_serialize_ns1__VpdnOnlineIPResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VpdnOnlineIPResponse(struct soap *soap, const char *tag, int id, struct ns1__VpdnOnlineIPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VpdnOnlineIPResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VpdnOnlineIPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__VpdnOnlineIPResponse ** SOAP_FMAC4 soap_in_PointerTons1__VpdnOnlineIPResponse(struct soap *soap, const char *tag, struct ns1__VpdnOnlineIPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__VpdnOnlineIPResponse **)soap_malloc(soap, sizeof(struct ns1__VpdnOnlineIPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__VpdnOnlineIPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__VpdnOnlineIPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VpdnOnlineIPResponse, sizeof(struct ns1__VpdnOnlineIPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VpdnOnlineIPResponse(struct soap *soap, struct ns1__VpdnOnlineIPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VpdnOnlineIPResponse);
	if (soap_out_PointerTons1__VpdnOnlineIPResponse(soap, tag?tag:"ns1:VpdnOnlineIPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VpdnOnlineIPResponse ** SOAP_FMAC4 soap_get_PointerTons1__VpdnOnlineIPResponse(struct soap *soap, struct ns1__VpdnOnlineIPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VpdnOnlineIPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VpdnOnlineIPRequest(struct soap *soap, struct ns1__VpdnOnlineIPRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VpdnOnlineIPRequest))
		soap_serialize_ns1__VpdnOnlineIPRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VpdnOnlineIPRequest(struct soap *soap, const char *tag, int id, struct ns1__VpdnOnlineIPRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VpdnOnlineIPRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VpdnOnlineIPRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__VpdnOnlineIPRequest ** SOAP_FMAC4 soap_in_PointerTons1__VpdnOnlineIPRequest(struct soap *soap, const char *tag, struct ns1__VpdnOnlineIPRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__VpdnOnlineIPRequest **)soap_malloc(soap, sizeof(struct ns1__VpdnOnlineIPRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__VpdnOnlineIPRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__VpdnOnlineIPRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VpdnOnlineIPRequest, sizeof(struct ns1__VpdnOnlineIPRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VpdnOnlineIPRequest(struct soap *soap, struct ns1__VpdnOnlineIPRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VpdnOnlineIPRequest);
	if (soap_out_PointerTons1__VpdnOnlineIPRequest(soap, tag?tag:"ns1:VpdnOnlineIPRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VpdnOnlineIPRequest ** SOAP_FMAC4 soap_get_PointerTons1__VpdnOnlineIPRequest(struct soap *soap, struct ns1__VpdnOnlineIPRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VpdnOnlineIPRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VpdnIPResponse(struct soap *soap, struct ns1__VpdnIPResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VpdnIPResponse))
		soap_serialize_ns1__VpdnIPResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VpdnIPResponse(struct soap *soap, const char *tag, int id, struct ns1__VpdnIPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VpdnIPResponse);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VpdnIPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__VpdnIPResponse ** SOAP_FMAC4 soap_in_PointerTons1__VpdnIPResponse(struct soap *soap, const char *tag, struct ns1__VpdnIPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__VpdnIPResponse **)soap_malloc(soap, sizeof(struct ns1__VpdnIPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__VpdnIPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__VpdnIPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VpdnIPResponse, sizeof(struct ns1__VpdnIPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VpdnIPResponse(struct soap *soap, struct ns1__VpdnIPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VpdnIPResponse);
	if (soap_out_PointerTons1__VpdnIPResponse(soap, tag?tag:"ns1:VpdnIPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VpdnIPResponse ** SOAP_FMAC4 soap_get_PointerTons1__VpdnIPResponse(struct soap *soap, struct ns1__VpdnIPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VpdnIPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__VpdnIPRequest(struct soap *soap, struct ns1__VpdnIPRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__VpdnIPRequest))
		soap_serialize_ns1__VpdnIPRequest(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__VpdnIPRequest(struct soap *soap, const char *tag, int id, struct ns1__VpdnIPRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__VpdnIPRequest);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__VpdnIPRequest(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__VpdnIPRequest ** SOAP_FMAC4 soap_in_PointerTons1__VpdnIPRequest(struct soap *soap, const char *tag, struct ns1__VpdnIPRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__VpdnIPRequest **)soap_malloc(soap, sizeof(struct ns1__VpdnIPRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__VpdnIPRequest(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__VpdnIPRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__VpdnIPRequest, sizeof(struct ns1__VpdnIPRequest), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__VpdnIPRequest(struct soap *soap, struct ns1__VpdnIPRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__VpdnIPRequest);
	if (soap_out_PointerTons1__VpdnIPRequest(soap, tag?tag:"ns1:VpdnIPRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__VpdnIPRequest ** SOAP_FMAC4 soap_get_PointerTons1__VpdnIPRequest(struct soap *soap, struct ns1__VpdnIPRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__VpdnIPRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
